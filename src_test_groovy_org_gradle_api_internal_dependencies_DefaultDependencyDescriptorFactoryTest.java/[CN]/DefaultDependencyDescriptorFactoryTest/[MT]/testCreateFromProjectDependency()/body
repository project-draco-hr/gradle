{
  final ProjectInternal projectMock=context.mock(ProjectInternal.class,"project");
  final ProjectInternal dependencyProjectMock=context.mock(ProjectInternal.class,"dependencyProject");
  final DependencyManager dependencyProjectDependencyManagerMock=context.mock(DependencyManager.class);
  final ModuleRevisionId testModuleRevisionId=ModuleRevisionId.newInstance("org","name","1.0",new HashMap());
  context.checking(new Expectations(){
{
      allowing(dependencyProjectMock).getDependencies();
      will(returnValue(dependencyProjectDependencyManagerMock));
      allowing(dependencyProjectDependencyManagerMock).createModuleRevisionId();
      will(returnValue(testModuleRevisionId));
    }
  }
);
  DefaultProjectDependency projectDependency=new DefaultProjectDependency(TEST_CONF_SET,dependencyProjectMock,projectMock).setTransitive(true);
  projectDependency.setExcludeRules(excludeRuleContainerMock);
  projectDependency.setDependencyConfigurationMappings(dependencyConfigurationMappingContainerMock);
  DefaultDependencyDescriptor dependencyDescriptor=(DefaultDependencyDescriptor)dependencyDescriptorFactory.createFromProjectDependency(TEST_PARENT,projectDependency);
  assertSame(TEST_PARENT.getModuleRevisionId(),dependencyDescriptor.getParentRevisionId());
  assertEquals(testModuleRevisionId,dependencyDescriptor.getDependencyRevisionId());
  assertEquals(projectDependency.isTransitive(),dependencyDescriptor.isTransitive());
  assertTrue(dependencyDescriptor.isChanging());
  assertFalse(dependencyDescriptor.isForce());
  checkDependencyConfigurations(dependencyDescriptor,projectDependency,WILDCARD_CONF);
  checkExcludeRules(dependencyDescriptor,excludeRuleWithAllConf,excludeRuleWithConf);
}
