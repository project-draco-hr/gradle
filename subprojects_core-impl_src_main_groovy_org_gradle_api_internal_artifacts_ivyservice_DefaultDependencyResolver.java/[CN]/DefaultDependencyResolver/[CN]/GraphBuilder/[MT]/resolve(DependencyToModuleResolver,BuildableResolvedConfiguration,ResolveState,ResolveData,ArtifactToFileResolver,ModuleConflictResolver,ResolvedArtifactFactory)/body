{
  SetMultimap<ModuleId,DependencyResolvePath> conflicts=LinkedHashMultimap.create();
  List<DependencyResolvePath> queue=new ArrayList<DependencyResolvePath>();
  resolveState.root.addOutgoingDependencies(new RootPath(),queue);
  while (!queue.isEmpty() || !conflicts.isEmpty()) {
    if (queue.isEmpty()) {
      ModuleId moduleId=conflicts.keySet().iterator().next();
      Set<ModuleRevisionResolveState> candidates=resolveState.getRevisions(moduleId);
      ModuleRevisionResolveState selected=conflictResolver.select(candidates,resolveState.root.moduleRevision);
      LOGGER.debug("Selected {} from conflicting modules {}.",selected,candidates);
      selected.status=Status.Include;
      for (      ModuleRevisionResolveState candidate : candidates) {
        if (candidate != selected) {
          candidate.status=Status.Evict;
          for (          DependencyResolvePath path : new LinkedHashSet<DependencyResolvePath>(candidate.incomingPaths)) {
            path.restart(selected,queue);
          }
        }
      }
      Set<DependencyResolvePath> paths=conflicts.removeAll(moduleId);
      for (      DependencyResolvePath path : paths) {
        path.restart(selected,queue);
      }
      continue;
    }
    DependencyResolvePath path=queue.remove(0);
    LOGGER.debug("Visiting path {}.",path);
    try {
      path.resolve(dependencyResolver,resolveState);
    }
 catch (    Throwable t) {
      result.addUnresolvedDependency(path.dependency.descriptor,t);
      continue;
    }
    if (path.targetModuleRevision.status == Status.Conflict) {
      LOGGER.debug("Found a conflict. Park this path.");
      conflicts.put(path.targetModuleRevision.id.getModuleId(),path);
    }
 else {
      path.addOutgoingDependencies(resolveData,resolveState,queue);
    }
  }
  for (  ConfigurationResolveState resolvedConfiguration : resolveState.getConfigurations()) {
    resolvedConfiguration.attachToParents(resolvedArtifactFactory,artifactResolver,result);
  }
}
