{
  System.out.println("-> RESOLVE " + root);
  SetMultimap<ModuleId,DependencyResolvePath> conflicts=LinkedHashMultimap.create();
  List<DependencyResolvePath> queue=new ArrayList<DependencyResolvePath>();
  root.addOutgoingDependencies(new RootPath(),queue);
  while (!queue.isEmpty() || !conflicts.isEmpty()) {
    if (queue.isEmpty()) {
      ModuleId moduleId=conflicts.keySet().iterator().next();
      Set<ModuleRevisionResolveState> candidates=resolveState.getRevisions(moduleId);
      System.out.println("selecting moduleId from conflicts " + candidates);
      ModuleRevisionResolveState selected=conflictResolver.select(candidates);
      System.out.println("  selected " + selected);
      selected.status=Status.Include;
      for (      ModuleRevisionResolveState candidate : candidates) {
        if (candidate != selected) {
          candidate.status=Status.Evict;
          for (          DependencyResolvePath path : candidate.incomingPaths) {
            path.restart(selected,queue);
          }
        }
      }
      Set<DependencyResolvePath> paths=conflicts.removeAll(moduleId);
      for (      DependencyResolvePath path : paths) {
        path.restart(selected,queue);
      }
      continue;
    }
    DependencyResolvePath path=queue.remove(0);
    System.out.println("* path " + path);
    try {
      path.resolve(resolver,resolveState);
    }
 catch (    Throwable t) {
      result.addUnresolvedDependency(path.dependency.descriptor,t);
      continue;
    }
    if (path.targetModuleRevision.status == Status.Conflict) {
      conflicts.put(path.targetModuleRevision.descriptor.getModuleRevisionId().getModuleId(),path);
    }
 else {
      path.addOutgoingDependencies(resolveData,resolveState,queue);
    }
  }
  for (  ConfigurationResolveState resolvedConfiguration : resolveState.getConfigurations()) {
    resolvedConfiguration.attachToParents(resolvedArtifactFactory,artifactResolver,result);
  }
}
