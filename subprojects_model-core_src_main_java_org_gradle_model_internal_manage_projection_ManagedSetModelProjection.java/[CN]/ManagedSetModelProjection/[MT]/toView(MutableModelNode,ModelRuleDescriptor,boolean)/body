{
  return new ModelView<ManagedSet<I>>(){
    private boolean closed;
    private Set<I> elementViews;
    @Override public ModelType<ManagedSet<I>> getType(){
      return ManagedSetModelProjection.this.getType();
    }
    @Override public ManagedSet<I> getInstance(){
      return new ModelNodeBackedManagedSet();
    }
    @Override public void close(){
      closed=true;
    }
    private void ensureReadable(){
      if (writable && !closed) {
        throw new WriteOnlyModelViewException(getType(),ruleDescriptor);
      }
      if (elementViews == null) {
        elementViews=new LinkedHashSet<I>();
        for (        MutableModelNode node : modelNode.getLinks(elementType)) {
          elementViews.add(node.asReadOnly(elementType,ruleDescriptor).getInstance());
        }
      }
    }
class ModelNodeBackedManagedSet implements ManagedSet<I>, ManagedInstance {
      @Override public MutableModelNode getBackingNode(){
        return modelNode;
      }
      @Override public String toString(){
        return String.format("%s '%s'",getType(),modelNode.getPath().toString());
      }
      @Override public void create(      final Action<? super I> action){
        if (!writable || closed) {
          throw new ModelViewClosedException(getType(),ruleDescriptor);
        }
        String name=String.valueOf(modelNode.getLinkCount(elementType));
        ModelPath path=modelNode.getPath().child(name);
        modelNode.addLink(modelCreatorFactory.creator(ruleDescriptor,path,elementSchema,Collections.<ModelReference<?>>emptyList(),new BiAction<I,Inputs>(){
          @Override public void execute(          I i,          Inputs inputs){
            action.execute(i);
          }
        }
));
      }
      @Override public int size(){
        ensureReadable();
        return elementViews.size();
      }
      @Override public boolean isEmpty(){
        ensureReadable();
        return elementViews.isEmpty();
      }
      @Override public boolean contains(      Object o){
        ensureReadable();
        return elementViews.contains(o);
      }
      @Override public Iterator<I> iterator(){
        ensureReadable();
        return elementViews.iterator();
      }
      @Override public Object[] toArray(){
        ensureReadable();
        return elementViews.toArray();
      }
      @Override public <T>T[] toArray(      T[] a){
        ensureReadable();
        return elementViews.toArray(a);
      }
      @Override public boolean add(      I e){
        throw new UnsupportedOperationException();
      }
      @Override public boolean remove(      Object o){
        throw new UnsupportedOperationException();
      }
      @Override public boolean containsAll(      Collection<?> c){
        ensureReadable();
        return elementViews.containsAll(c);
      }
      @Override public boolean addAll(      Collection<? extends I> c){
        throw new UnsupportedOperationException();
      }
      @Override public boolean retainAll(      Collection<?> c){
        throw new UnsupportedOperationException();
      }
      @Override public boolean removeAll(      Collection<?> c){
        throw new UnsupportedOperationException();
      }
      @Override public void clear(){
        throw new UnsupportedOperationException();
      }
      public void create(      Closure<?> closure){
        create(new ClosureBackedAction<I>(closure));
      }
    }
  }
;
}
