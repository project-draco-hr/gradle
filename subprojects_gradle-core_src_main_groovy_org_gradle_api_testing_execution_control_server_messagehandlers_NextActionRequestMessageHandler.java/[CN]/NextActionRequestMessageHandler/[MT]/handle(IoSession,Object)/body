{
  final NextActionRequestMessage message=(NextActionRequestMessage)controlMessage;
  final int forkId=message.getForkId();
  if (pipelineDispatcher.isStopping()) {
    ioSession.write(new StopForkActionMessage(pipeline.getId()));
  }
 else {
    if (pipelineDispatcher.isAllTestsExecuted() && pipelineDispatcher.isPipelineSplittingEnded()) {
      ioSession.write(new StopForkActionMessage(pipeline.getId()));
      pipelineDispatcher.stop();
    }
 else {
      final TestClassProcessResult previousProcessedTestResult=message.getPreviousProcessedTestResult();
      if (previousProcessedTestResult != null) {
      }
      final ReforkDecisionContext reforkDecisionContext=message.getReforkDecisionContext();
      boolean reforkNeeded=false;
      if (reforkDecisionContext != null) {
        reforkNeeded=pipelineDispatcher.determineReforkNeeded(forkId,reforkDecisionContext);
      }
      if (reforkNeeded) {
        pipelineDispatcher.scheduleForkRestart(forkId);
        ioSession.write(new StopForkActionMessage(pipeline.getId()));
      }
 else {
        boolean wait=false;
        if (pipelineDispatcher.getClientHandle(forkId).getStatus() == ForkStatus.TESTING) {
          TestClassRunInfo nextTest=pipelineDispatcher.getNextTest();
          if (nextTest != null) {
            ioSession.write(new ExecuteTestActionMessage(pipeline.getId(),nextTest));
          }
 else {
            wait=true;
          }
        }
 else {
          wait=!reforkNeeded;
        }
        if (wait) {
          ioSession.write(new WaitActionMesssage(pipeline.getId(),1000));
        }
      }
    }
  }
}
