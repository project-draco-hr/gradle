{
  URL[] classLoaderURLs=((URLClassLoader)(Thread.currentThread().getContextClassLoader())).getURLs();
  URL pluginClasspathUrl=CollectionUtils.findFirst(classLoaderURLs,new Spec<URL>(){
    @Override public boolean isSatisfiedBy(    URL url){
      return url.toString().endsWith(String.format("pluginClasspathManifest/%s",PLUGIN_METADATA_FILE_NAME));
    }
  }
);
  if (pluginClasspathUrl == null) {
    throw new InvalidPluginMetadataException(String.format("Test runtime classpath does not contain plugin metadata file '%s'",PLUGIN_METADATA_FILE_NAME));
  }
  Properties properties=GUtil.loadProperties(pluginClasspathUrl);
  if (!properties.isEmpty()) {
    if (!properties.containsKey(IMPLEMENTATION_CLASSPATH_PROP_KEY)) {
      throw new InvalidPluginMetadataException(String.format("Plugin metadata file '%s' does not contain expected property named '%s'",PLUGIN_METADATA_FILE_NAME,IMPLEMENTATION_CLASSPATH_PROP_KEY));
    }
    String[] parsedImplementationClasspath=properties.getProperty(IMPLEMENTATION_CLASSPATH_PROP_KEY).split(",");
    return CollectionUtils.collect(parsedImplementationClasspath,new Transformer<File,String>(){
      @Override public File transform(      String classpathEntry){
        return new File(classpathEntry);
      }
    }
);
  }
  return Collections.emptyList();
}
