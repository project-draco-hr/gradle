{
  URL pluginClasspathUrl=Thread.currentThread().getContextClassLoader().getResource(PLUGIN_METADATA_FILE_NAME);
  if (pluginClasspathUrl == null) {
    throw new InvalidPluginMetadataException(String.format("Test runtime classpath does not contain plugin metadata file '%s'",PLUGIN_METADATA_FILE_NAME));
  }
  Properties properties=GUtil.loadProperties(pluginClasspathUrl);
  if (!properties.containsKey(IMPLEMENTATION_CLASSPATH_PROP_KEY)) {
    throw new InvalidPluginMetadataException(String.format("Plugin metadata file '%s' does not contain expected property named '%s'",PLUGIN_METADATA_FILE_NAME,IMPLEMENTATION_CLASSPATH_PROP_KEY));
  }
  String value=properties.getProperty(IMPLEMENTATION_CLASSPATH_PROP_KEY);
  if (value != null) {
    value=value.trim();
  }
  if (value == null || value.isEmpty()) {
    throw new InvalidPluginMetadataException(String.format("Plugin metadata file '%s' has empty value for property named '%s'",PLUGIN_METADATA_FILE_NAME,IMPLEMENTATION_CLASSPATH_PROP_KEY));
  }
  String[] parsedImplementationClasspath=value.trim().split(File.pathSeparator);
  return CollectionUtils.collect(parsedImplementationClasspath,new Transformer<File,String>(){
    @Override public File transform(    String classpathEntry){
      return new File(classpathEntry);
    }
  }
);
}
