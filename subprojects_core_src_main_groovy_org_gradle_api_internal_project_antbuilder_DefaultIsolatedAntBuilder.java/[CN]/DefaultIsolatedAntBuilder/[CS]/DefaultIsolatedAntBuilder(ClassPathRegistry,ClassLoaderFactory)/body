{
  this.classPathRegistry=classPathRegistry;
  this.classLoaderFactory=classLoaderFactory;
  this.classLoaderCache=Maps.newConcurrentMap();
  this.libClasspath=new DefaultClassPath();
  List<File> antClasspath=Lists.newArrayList(classPathRegistry.getClassPath("ANT").getAsFiles());
  File toolsJar=Jvm.current().getToolsJar();
  if (toolsJar != null) {
    antClasspath.add(toolsJar);
  }
  ClassLoader antLoader=classLoaderFactory.createIsolatedClassLoader(new DefaultClassPath(antClasspath));
  FilteringClassLoader loggingLoader=new FilteringClassLoader(getClass().getClassLoader());
  loggingLoader.allowPackage("org.slf4j");
  loggingLoader.allowPackage("org.apache.commons.logging");
  loggingLoader.allowPackage("org.apache.log4j");
  loggingLoader.allowClass(Logger.class);
  loggingLoader.allowClass(LogLevel.class);
  this.baseAntLoader=new CachingClassLoader(new MultiParentClassLoader(antLoader,loggingLoader));
  ClassPath gradleCoreUrls=classPathRegistry.getClassPath("GRADLE_CORE");
  gradleCoreUrls=gradleCoreUrls.plus(classPathRegistry.getClassPath("GROOVY"));
  gradleCoreUrls=gradleCoreUrls.plus(classPathRegistry.getClassPath("GRADLE_BASE_SERVICES"));
  this.gradleLoader=new URLClassLoader(gradleCoreUrls.getAsURLArray(),baseAntLoader);
  finalizerThread=new FinalizerThread(classLoaderCache);
  finalizerThread.start();
  this.gradleToIsolatedLeakPrevention=new MemoryLeakPrevention(CORE_GRADLE_LOADER,this.getClass().getClassLoader(),null);
  this.antToGradleLeakPrevention=new MemoryLeakPrevention(ANT_GRADLE_LOADER,gradleLoader,gradleCoreUrls);
  this.gradleToIsolatedLeakPrevention.prepare();
  this.antToGradleLeakPrevention.prepare();
  FINALIZERS.add(new Finalizer(this,FINALIZER_REFQUEUE));
}
