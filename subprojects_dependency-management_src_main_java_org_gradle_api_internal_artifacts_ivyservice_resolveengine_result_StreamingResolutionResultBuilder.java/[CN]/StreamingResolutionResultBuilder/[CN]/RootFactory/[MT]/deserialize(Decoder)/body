{
  int valuesRead=0;
  byte type=-1;
  Clock clock=new Clock();
  try {
    DefaultResolutionResultBuilder builder=new DefaultResolutionResultBuilder();
    while (true) {
      type=decoder.readByte();
      valuesRead++;
switch (type) {
case ROOT:
        ModuleVersionIdentifier id=moduleVersionIdentifierSerializer.read(decoder);
      ComponentIdentifier componentIdentifier=componentIdentifierSerializer.read(decoder);
    builder.start(id,componentIdentifier);
  break;
case MODULE:
ComponentResult sel=componentResultSerializer.read(decoder);
builder.resolvedModuleVersion(sel);
break;
case DEPENDENCY:
id=moduleVersionIdentifierSerializer.read(decoder);
int size=decoder.readSmallInt();
List<DependencyResult> deps=new ArrayList<DependencyResult>(size);
for (int i=0; i < size; i++) {
deps.add(dependencyResultSerializer.read(decoder,failures));
}
builder.resolvedConfiguration(id,deps);
break;
case DONE:
ResolvedComponentResult root=builder.complete().getRoot();
LOG.debug("Loaded resolution results ({}) from {}",clock.getTime(),data);
return root;
default :
throw new IOException("Unknown value type read from stream: " + type);
}
}
}
 catch (IOException e) {
throw new RuntimeException("Problems loading the resolution results (" + clock.getTime() + "). "+ "Read "+ valuesRead+ " values, last was: "+ type,e);
}
}
