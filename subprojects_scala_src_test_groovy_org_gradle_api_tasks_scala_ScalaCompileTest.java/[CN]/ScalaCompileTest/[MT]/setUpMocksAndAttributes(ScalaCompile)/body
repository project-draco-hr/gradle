{
  compile.source(srcDir);
  compile.setIncludes(TEST_INCLUDES);
  compile.setExcludes(TEST_EXCLUDES);
  compile.setSourceCompatibility("1.5");
  compile.setTargetCompatibility("1.5");
  compile.setDestinationDir(destDir);
  scalaClasspath=context.mock(FileTreeInternal.class);
  compile.setScalaClasspath(scalaClasspath);
  final FileTreeInternal classpath=context.mock(FileTreeInternal.class);
  final FileTreeInternal zincClasspath=context.mock(FileTreeInternal.class);
  context.checking(new Expectations(){
{
      allowing(scalaClasspath).getFiles();
      will(returnValue(new HashSet<File>()));
      allowing(scalaClasspath).visit((FileVisitor)with(anything()));
      allowing(scalaClasspath).visitTreeOrBackingFile((FileVisitor)with(anything()));
      allowing(scalaClasspath).iterator();
      will(returnIterator());
      allowing(classpath).getFiles();
      will(returnValue(new HashSet<File>()));
      allowing(classpath).visit((FileVisitor)with(anything()));
      allowing(classpath).visitTreeOrBackingFile((FileVisitor)with(anything()));
      allowing(classpath).iterator();
      will(returnIterator());
      allowing(zincClasspath).getFiles();
      will(returnValue(new HashSet<File>()));
      allowing(zincClasspath).visit((FileVisitor)with(anything()));
      allowing(zincClasspath).visitTreeOrBackingFile((FileVisitor)with(anything()));
      allowing(zincClasspath).iterator();
      will(returnIterator());
    }
  }
);
  compile.setClasspath(classpath);
  compile.setZincClasspath(zincClasspath);
  ScalaCompileOptions options=compile.getScalaCompileOptions();
  options.getIncrementalOptions().setAnalysisFile(new File("analysisFile"));
}
