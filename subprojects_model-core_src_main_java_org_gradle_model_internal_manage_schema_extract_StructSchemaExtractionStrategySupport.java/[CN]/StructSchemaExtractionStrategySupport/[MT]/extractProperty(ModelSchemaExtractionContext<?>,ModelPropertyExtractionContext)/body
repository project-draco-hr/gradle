{
  PropertyAccessorExtractionContext gettersContext=property.mergeGetters();
  final ModelType<R> returnType=ModelType.returnType(gettersContext.getMostSpecificDeclaration());
  WeaklyTypeReferencingMethod<?,Void> setterRef;
  PropertyAccessorExtractionContext setterContext=property.getAccessor(PropertyAccessorType.SETTER);
  if (setterContext != null) {
    Method mostSpecificDeclaration=setterContext.getMostSpecificDeclaration();
    setterRef=WeaklyTypeReferencingMethod.of(ModelType.of(mostSpecificDeclaration.getDeclaringClass()),ModelType.of(void.class),mostSpecificDeclaration);
  }
 else {
    setterRef=null;
  }
  ImmutableSet<ModelType<?>> declaringClasses=ImmutableSet.copyOf(Iterables.transform(gettersContext.getDeclaringMethods(),new Function<Method,ModelType<?>>(){
    public ModelType<?> apply(    Method input){
      return ModelType.of(input.getDeclaringClass());
    }
  }
));
  List<WeaklyTypeReferencingMethod<?,R>> getterRefs=Lists.newArrayList(Iterables.transform(gettersContext.getGetters(),new Function<Method,WeaklyTypeReferencingMethod<?,R>>(){
    @Override public WeaklyTypeReferencingMethod<?,R> apply(    Method getter){
      return WeaklyTypeReferencingMethod.of(ModelType.of(getter.getDeclaringClass()),returnType,getter);
    }
  }
));
  ModelProperty.StateManagementType stateManagementType=determineStateManagementType(context,gettersContext);
  boolean declaredAsHavingUnmanagedType=gettersContext.getAnnotation(Unmanaged.class) != null;
  return new ModelPropertyExtractionResult<R>(new ModelProperty<R>(returnType,property.getPropertyName(),stateManagementType,declaringClasses,getterRefs,setterRef,declaredAsHavingUnmanagedType),gettersContext,setterContext);
}
