{
  Map<String,ModelPropertyExtractionContext> propertiesMap=Maps.newTreeMap();
  for (  Map.Entry<Equivalence.Wrapper<Method>,Collection<Method>> entry : candidateMethods.allMethods().entrySet()) {
    Method method=entry.getKey().get();
    PropertyAccessorType propertyAccessorType=PropertyAccessorType.of(method);
    Collection<Method> methodsWithEqualSignature=entry.getValue();
    if (propertyAccessorType == null) {
      handleNonPropertyMethod(context,methodsWithEqualSignature);
    }
 else {
      String propertyName=propertyAccessorType.propertyNameFor(method);
      ModelPropertyExtractionContext propertyContext=propertiesMap.get(propertyName);
      if (propertyContext == null) {
        propertyContext=new ModelPropertyExtractionContext(propertyName);
        propertiesMap.put(propertyName,propertyContext);
      }
switch (propertyAccessorType) {
case GET_GETTER:
        propertyContext.setGetGetter(new PropertyAccessorExtractionContext(methodsWithEqualSignature));
      break;
case IS_GETTER:
    propertyContext.setIsGetter(new PropertyAccessorExtractionContext(methodsWithEqualSignature));
  break;
case SETTER:
propertyContext.setSetter(new PropertyAccessorExtractionContext(methodsWithEqualSignature));
break;
default :
throw new AssertionError();
}
}
}
return Collections2.filter(propertiesMap.values(),new Predicate<ModelPropertyExtractionContext>(){
@Override public boolean apply(ModelPropertyExtractionContext property){
return selectProperty(context,property);
}
}
);
}
