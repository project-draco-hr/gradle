{
  List<ModelPropertyExtractionResult<?>> results=Lists.newArrayList();
  Set<Method> handledMethods=Sets.newHashSet();
  List<String> methodNames=Lists.newArrayList(methodsByName.keySet());
  Collections.sort(methodNames);
  Set<String> skippedMethodNames=Sets.newHashSet();
  for (  String methodName : methodNames) {
    if (skippedMethodNames.contains(methodName)) {
      continue;
    }
    Collection<Method> methods=methodsByName.get(methodName);
    List<Method> overloadedMethods=getOverloadedMethods(methods);
    if (overloadedMethods != null) {
      handleOverloadedMethods(extractionContext,overloadedMethods);
      continue;
    }
    int getterPrefixLen=getterPrefixLength(methodName);
    if (getterPrefixLen >= 0) {
      Method mostSpecificGetter=ModelSchemaUtils.findMostSpecificMethod(methods);
      Character getterPropertyNameFirstChar=methodName.charAt(getterPrefixLen);
      if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
        handleInvalidGetter(extractionContext,mostSpecificGetter,String.format("the %s character of the getter method name must be an uppercase character",getterPrefixLen == 2 ? "3rd" : "4th"));
        continue;
      }
      String propertyNameCapitalized=methodName.substring(getterPrefixLen);
      String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
      String setterName="set" + propertyNameCapitalized;
      Collection<Method> setterMethods=methodsByName.get(setterName);
      PropertyAccessorExtractionContext setterContext=!setterMethods.isEmpty() ? new PropertyAccessorExtractionContext(setterMethods) : null;
      String prefix=methodName.substring(0,getterPrefixLen);
      Iterable<Method> getterMethods;
      if (prefix.equals("get") && mostSpecificGetter.getReturnType() == boolean.class) {
        String isGetterName="is" + propertyNameCapitalized;
        Collection<Method> isGetterMethods=methodsByName.get(isGetterName);
        List<Method> overloadedIsGetterMethods=getOverloadedMethods(isGetterMethods);
        if (overloadedIsGetterMethods != null) {
          handleOverloadedMethods(extractionContext,overloadedIsGetterMethods);
          continue;
        }
        getterMethods=Iterables.concat(methods,isGetterMethods);
        skippedMethodNames.add(isGetterName);
      }
 else {
        getterMethods=methods;
      }
      PropertyAccessorExtractionContext getterContext=new PropertyAccessorExtractionContext(getterMethods);
      ModelPropertyExtractionResult<?> result=extractPropertySchema(extractionContext,propertyName,getterContext,setterContext,getterPrefixLen);
      if (result != null) {
        results.add(result);
        handledMethods.addAll(getterContext.getDeclaringMethods());
        if (setterContext != null) {
          handledMethods.addAll(setterContext.getDeclaringMethods());
        }
      }
    }
  }
  validateAllNecessaryMethodsHandled(extractionContext,methodsByName.values(),handledMethods);
  return results;
}
