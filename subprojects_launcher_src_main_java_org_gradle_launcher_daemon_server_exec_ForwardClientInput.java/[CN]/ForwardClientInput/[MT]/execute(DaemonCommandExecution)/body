{
  final PipedOutputStream inputSource=new PipedOutputStream();
  final PipedInputStream replacementStdin;
  try {
    replacementStdin=new PipedInputStream(inputSource);
  }
 catch (  IOException e) {
    throw new GradleException("unable to wire client stdin to daemon stdin",e);
  }
  final CountDownLatch inputOrConnectionClosedLatch=new CountDownLatch(1);
  final Runnable countDownInputOrConnectionClosedLatch=new Runnable(){
    public void run(){
      inputOrConnectionClosedLatch.countDown();
    }
  }
;
  Dispatch<Object> dispatcher=new Dispatch<Object>(){
    public void dispatch(    Object command){
      if (command instanceof ForwardInput) {
        try {
          ForwardInput forwardedInput=(ForwardInput)command;
          LOGGER.info("putting forwarded input '{}' on daemon's stdin",new String(forwardedInput.getBytes()).replace("\n","\\n"));
          inputSource.write(forwardedInput.getBytes());
        }
 catch (        IOException e) {
          LOGGER.warn("received IO exception trying to forward client input",e);
        }
      }
 else       if (command instanceof CloseInput) {
        try {
          LOGGER.info("received {}, closing daemons stdin",command);
          inputSource.close();
        }
 catch (        IOException e) {
          LOGGER.warn("IO exception closing output stream connected to replacement stdin",e);
        }
 finally {
          countDownInputOrConnectionClosedLatch.run();
        }
      }
 else {
        LOGGER.warn("while listening for IOCommands, received unexpected command: {}",command);
      }
    }
  }
;
  StoppableExecutor inputReceiverExecuter=executorFactory.create("daemon client input forwarder");
  AsyncReceive<Object> inputReceiver=new AsyncReceive<Object>(inputReceiverExecuter,dispatcher,countDownInputOrConnectionClosedLatch);
  inputReceiver.receiveFrom(execution.getConnection());
  try {
    new StdinSwapper().swap(replacementStdin,new Callable<Void>(){
      public Void call(){
        execution.proceed();
        return null;
      }
    }
);
    replacementStdin.close();
  }
 catch (  Exception e) {
    throw UncheckedException.asUncheckedException(e);
  }
 finally {
    try {
      inputOrConnectionClosedLatch.await();
    }
 catch (    InterruptedException e) {
      throw UncheckedException.asUncheckedException(e);
    }
    inputReceiver.stop();
  }
}
