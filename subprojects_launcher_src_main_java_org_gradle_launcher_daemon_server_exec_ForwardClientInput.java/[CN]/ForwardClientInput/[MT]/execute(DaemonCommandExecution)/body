{
  final PipedOutputStream inputSource=new PipedOutputStream();
  final PipedInputStream replacementStdin;
  try {
    replacementStdin=new PipedInputStream(inputSource);
  }
 catch (  IOException e) {
    throw new GradleException("unable to wire client stdin to daemon stdin",e);
  }
  Dispatch<Object> dispatcher=new Dispatch<Object>(){
    public void dispatch(    Object command){
      if (command instanceof ForwardInput) {
        try {
          ForwardInput forwardedInput=(ForwardInput)command;
          inputSource.write(forwardedInput.getBytes());
        }
 catch (        IOException e) {
          LOGGER.warn("received IO exception trying to forward client input",e);
        }
      }
 else       if (command instanceof CloseInput) {
        try {
          inputSource.close();
        }
 catch (        IOException e) {
          LOGGER.warn("IO exception closing output stream connected to replacement stdin",e);
        }
      }
 else {
        LOGGER.warn("while listening for IOCommands, received unexpected command: {}",command);
      }
    }
  }
;
  ExecutorFactory inputReceiverExecuterFactory=new DefaultExecutorFactory();
  StoppableExecutor inputReceiverExecuter=inputReceiverExecuterFactory.create("daemon client input forwarder");
  AsyncReceive<Object> inputReceiver=new AsyncReceive<Object>(inputReceiverExecuter,dispatcher);
  inputReceiver.receiveFrom(execution.getConnection());
  try {
    new StdinSwapper().swap(replacementStdin,new Callable<Void>(){
      public Void call(){
        execution.proceed();
        return null;
      }
    }
);
    replacementStdin.close();
  }
 catch (  Exception e) {
    throw UncheckedException.asUncheckedException(e);
  }
 finally {
    inputReceiver.requestStop();
  }
}
