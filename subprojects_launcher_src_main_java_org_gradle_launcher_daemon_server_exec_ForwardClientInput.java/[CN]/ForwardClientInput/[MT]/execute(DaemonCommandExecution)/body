{
  final PipedOutputStream inputSource=new PipedOutputStream();
  final PipedInputStream replacementStdin;
  try {
    replacementStdin=new PipedInputStream(inputSource);
  }
 catch (  IOException e) {
    throw new GradleException("unable to wire client stdin to daemon stdin",e);
  }
  final CountDownLatch inputOrConnectionClosedLatch=new CountDownLatch(1);
  final Runnable countDownInputOrConnectionClosedLatch=new Runnable(){
    public void run(){
      inputOrConnectionClosedLatch.countDown();
    }
  }
;
  Dispatch<Object> dispatcher=new Dispatch<Object>(){
    public void dispatch(    Object command){
      if (command instanceof ForwardInput) {
        try {
          ForwardInput forwardedInput=(ForwardInput)command;
          LOGGER.info("Putting forwarded input '{}' on daemon's stdin",new String(forwardedInput.getBytes()).replace("\n","\\n"));
          inputSource.write(forwardedInput.getBytes());
        }
 catch (        IOException e) {
          LOGGER.warn("Received IO exception trying to forward client input",e);
        }
      }
 else       if (command instanceof CloseInput) {
        try {
          LOGGER.info("Closing daemons standard input as requested by received command: {}",command);
          inputSource.close();
        }
 catch (        IOException e) {
          LOGGER.warn("IO exception closing output stream connected to replacement stdin",e);
        }
 finally {
          countDownInputOrConnectionClosedLatch.run();
        }
      }
 else {
        LOGGER.warn("While listening for IOCommands, received unexpected command: {}",command);
      }
    }
  }
;
  StoppableExecutor inputReceiverExecuter=executorFactory.create("daemon client input forwarder");
  final AsyncReceive<Object> inputReceiver=new AsyncReceive<Object>(inputReceiverExecuter,dispatcher,countDownInputOrConnectionClosedLatch);
  inputReceiver.receiveFrom(execution.getConnection());
  execution.addFinalizer(new Runnable(){
    public void run(){
      try {
        LOGGER.debug("Waiting until the client disconnects so that we may no longer consume input...");
        inputOrConnectionClosedLatch.await();
      }
 catch (      InterruptedException e) {
        LOGGER.debug("Interrupted while waiting for client to disconnect.");
        throw UncheckedException.asUncheckedException(e);
      }
 finally {
        inputReceiver.stop();
        LOGGER.debug("The input receiver has been stopped.");
      }
    }
  }
);
  try {
    new StdinSwapper().swap(replacementStdin,new Callable<Void>(){
      public Void call(){
        execution.proceed();
        return null;
      }
    }
);
    replacementStdin.close();
  }
 catch (  Exception e) {
    throw UncheckedException.asUncheckedException(e);
  }
}
