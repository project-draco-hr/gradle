{
  TypeBuilderInternal<T> builder=typeBuilderFactory.create();
  ruleDefinition.getRuleInvoker().invoke(builder);
  Class<? extends T> implementation=builder.getDefaultImplementation();
  if (implementation == null) {
    return null;
  }
  ModelType<? extends T> implementationType=ModelType.of(implementation);
  ModelType<? extends U> asSubclass=baseImplementation.asSubclass(implementationType);
  if (asSubclass == null) {
    throw new InvalidComponentModelException(String.format("%s implementation '%s' must extend '%s'.",StringUtils.capitalize(modelName),implementationType,baseImplementation));
  }
  if (!type.isAssignableFrom(asSubclass)) {
    throw new InvalidComponentModelException(String.format("%s implementation '%s' must implement '%s'.",StringUtils.capitalize(modelName),asSubclass,type));
  }
  try {
    asSubclass.getRawClass().getConstructor();
  }
 catch (  NoSuchMethodException nsmException) {
    throw new InvalidComponentModelException(String.format("%s implementation '%s' must have public default constructor.",StringUtils.capitalize(modelName),asSubclass));
  }
  return asSubclass;
}
