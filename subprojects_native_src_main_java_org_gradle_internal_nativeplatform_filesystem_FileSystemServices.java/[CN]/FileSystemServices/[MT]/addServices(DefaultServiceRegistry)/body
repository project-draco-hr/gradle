{
  OperatingSystem operatingSystem=OperatingSystem.current();
  if (operatingSystem.isWindows()) {
    serviceRegistry.add(Chmod.class,new EmptyChmod());
    serviceRegistry.add(Stat.class,new FallbackStat());
    serviceRegistry.add(Symlink.class,new FallbackSymlink());
    return;
  }
  LibC libC=loadLibC();
  serviceRegistry.add(Symlink.class,createSymlink(libC));
  if (libC != null && (operatingSystem.isLinux() || operatingSystem.isMacOsX())) {
    FilePathEncoder filePathEncoder=createEncoder(libC);
    serviceRegistry.add(Chmod.class,new LibcChmod(libC,filePathEncoder));
    POSIX posix=PosixUtil.current();
    if (posix instanceof BaseNativePOSIX) {
      serviceRegistry.add(Stat.class,new LibCStat(libC,operatingSystem,(BaseNativePOSIX)posix,filePathEncoder));
    }
    return;
  }
  if (JavaVersion.current().isJava7()) {
    String jdkFilePermissionclass="org.gradle.internal.nativeplatform.filesystem.jdk7.PosixJdk7FilePermissionHandler";
    try {
      Object handler=FileSystemServices.class.getClassLoader().loadClass(jdkFilePermissionclass).newInstance();
      serviceRegistry.add(Stat.class,(Stat)handler);
      serviceRegistry.add(Chmod.class,(Chmod)handler);
      return;
    }
 catch (    ClassNotFoundException e) {
      LOGGER.warn(String.format("Unable to load %s. Continuing with fallback.",jdkFilePermissionclass));
    }
catch (    Exception e) {
      throw UncheckedException.throwAsUncheckedException(e);
    }
  }
  serviceRegistry.add(Chmod.class,createChmod(libC));
  serviceRegistry.add(Stat.class,createStat());
}
