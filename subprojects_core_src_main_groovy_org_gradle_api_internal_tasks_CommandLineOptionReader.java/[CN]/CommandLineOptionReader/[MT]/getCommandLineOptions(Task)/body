{
  final Class<? extends Task> taskClazz=task.getClass();
  Map<String,CommandLineOptionDescriptor> options=new HashMap<String,CommandLineOptionDescriptor>();
  if (!cachedStaticDescriptors.containsKey(task.getClass())) {
    for (Class<?> type=taskClazz; type != Object.class && type != null; type=type.getSuperclass()) {
      for (      Method method : type.getDeclaredMethods()) {
        if (!Modifier.isStatic(method.getModifiers())) {
          CommandLineOption commandLineOption=method.getAnnotation(CommandLineOption.class);
          if (commandLineOption != null) {
            StaticCommandLineOptionDescriptor staticCommandLineOptionDescriptor=new StaticCommandLineOptionDescriptor(commandLineOption,method);
            assertMethodTypeSupported(staticCommandLineOptionDescriptor,taskClazz,method);
            CommandLineOptionDescriptor optionDescriptor=new InstanceCommandLineOptionDescriptor(task,staticCommandLineOptionDescriptor);
            if (options.containsKey(optionDescriptor.getName())) {
              throw new CommandLineArgumentException(String.format("Option '%s' linked to multiple methods in class '%s'.",optionDescriptor.getName(),taskClazz.getName()));
            }
            cachedStaticDescriptors.put(taskClazz,staticCommandLineOptionDescriptor);
            options.put(optionDescriptor.getName(),optionDescriptor);
          }
        }
      }
    }
  }
 else {
    for (    StaticCommandLineOptionDescriptor staticCommandLineOptionDescriptor : cachedStaticDescriptors.get(taskClazz)) {
      options.put(staticCommandLineOptionDescriptor.getName(),new InstanceCommandLineOptionDescriptor(task,staticCommandLineOptionDescriptor));
    }
  }
  return CollectionUtils.sort(options.values());
}
