{
  SourceLocation sourceLocation=ruleLocationExtractor.transform(closure);
  final ModelRuleDescriptor descriptor=sourceLocation.asDescriptor("model." + subjectPath);
  return new DeferredModelAction(){
    @Override public ModelRuleDescriptor getDescriptor(){
      return descriptor;
    }
    @Override public void execute(    MutableModelNode node,    ModelActionRole role){
      TransformedClosure transformedClosure=(TransformedClosure)closure;
      final boolean supportsNestedRules=node.canBeViewedAs(ModelType.of(ManagedInstance.class));
      InputReferences inputs=transformedClosure.inputReferences();
      List<InputReference> inputReferences=supportsNestedRules ? inputs.getOwnReferences() : inputs.getAllReferences();
      final Map<String,PotentialInput> inputValues=Maps.newLinkedHashMap();
      List<ModelReference<?>> inputModelReferences=Lists.newArrayList();
      for (      InputReference inputReference : inputReferences) {
        String description=String.format("@ line %d",inputReference.getLineNumber());
        String path=inputReference.getPath();
        if (!inputValues.containsKey(path)) {
          inputValues.put(path,new PotentialInput(inputModelReferences.size()));
          inputModelReferences.add(ModelReference.untyped(ModelPath.path(path),description));
        }
      }
      node.applyToSelf(role,InputUsingModelAction.of(ModelReference.of(subjectPath,subjectType),descriptor,inputModelReferences,new BiAction<T,List<ModelView<?>>>(){
        @Override public void execute(        T t,        List<ModelView<?>> modelViews){
          Closure<?> cloned=closure.rehydrate(null,closure.getThisObject(),closure.getThisObject());
          ((TransformedClosure)cloned).makeRule(new PotentialInputs(modelViews,inputValues),supportsNestedRules);
          ClosureBackedAction.execute(t,cloned);
        }
      }
));
    }
  }
;
}
