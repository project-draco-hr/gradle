{
  final File archivePath=new File(destinationDir,archiveName);
  if (!inputs.isIncremental()) {
    FileUtils.deleteQuietly(archivePath);
    FileUtils.deleteDirectory(apiClassesDir);
  }
  destinationDir.mkdirs();
  apiClassesDir.mkdirs();
  final ApiUnitExtractor apiUnitExtractor=new ApiUnitExtractor(exportedPackages);
  final AtomicBoolean updated=new AtomicBoolean();
  final Map<File,byte[]> apiUnits=Maps.newHashMap();
  inputs.outOfDate(new ErroringAction<InputFileDetails>(){
    @Override protected void doExecute(    InputFileDetails inputFileDetails) throws Exception {
      updated.set(true);
      File originalUnitFile=inputFileDetails.getFile();
      if (apiUnitExtractor.shouldExtractApiUnitFrom(originalUnitFile)) {
        final byte[] apiUnitBytes=apiUnitExtractor.extractApiUnitFrom(originalUnitFile);
        apiUnits.put(originalUnitFile,apiUnitBytes);
        File apiUnitFile=apiUnitFileFor(originalUnitFile);
        apiUnitFile.getParentFile().mkdirs();
        IoActions.withResource(new FileOutputStream(apiUnitFile),new ErroringAction<OutputStream>(){
          @Override protected void doExecute(          OutputStream outputStream) throws Exception {
            outputStream.write(apiUnitBytes);
          }
        }
);
      }
    }
  }
);
  inputs.removed(new ErroringAction<InputFileDetails>(){
    @Override protected void doExecute(    InputFileDetails removedOriginalUnit) throws Exception {
      updated.set(true);
      deleteApiUnitFileFor(removedOriginalUnit.getFile());
    }
  }
);
  if (updated.get()) {
    IoActions.withResource(new JarOutputStream(new BufferedOutputStream(new FileOutputStream(archivePath),65536)),new ErroringAction<JarOutputStream>(){
      private final SortedMap<String,File> sortedFiles=Maps.newTreeMap();
      private void writeEntries(      JarOutputStream jos) throws Exception {
        for (        Map.Entry<String,File> entry : sortedFiles.entrySet()) {
          JarEntry ze=new JarEntry(entry.getKey());
          ze.setTime(0);
          File originalUnitFile=entry.getValue();
          byte[] apiUnitBytes=apiUnits.get(originalUnitFile);
          if (apiUnitBytes == null) {
            apiUnitBytes=FileUtils.readFileToByteArray(originalUnitFile);
          }
          ze.setSize(apiUnitBytes.length);
          jos.putNextEntry(ze);
          jos.write(apiUnitBytes);
          jos.closeEntry();
        }
      }
      private void collectFiles(      String relativePath,      File f) throws Exception {
        String path="".equals(relativePath) ? f.getName() : relativePath + "/" + f.getName();
        if (f.isFile()) {
          sortedFiles.put(path,f);
        }
 else         if (f.isDirectory()) {
          for (          File file : f.listFiles()) {
            String root=relativePath == null ? "" : path;
            collectFiles(root,file);
          }
        }
      }
      @Override protected void doExecute(      final JarOutputStream jos) throws Exception {
        writeManifest(jos);
        collectFiles(null,apiClassesDir);
        writeEntries(jos);
        jos.close();
      }
      private void writeManifest(      JarOutputStream jos) throws IOException {
        JarEntry je=new JarEntry("META-INF/MANIFEST.MF");
        je.setTime(0);
        jos.putNextEntry(je);
        jos.write("Manifest-Version: 1.0\n".getBytes());
        jos.closeEntry();
      }
    }
);
  }
}
