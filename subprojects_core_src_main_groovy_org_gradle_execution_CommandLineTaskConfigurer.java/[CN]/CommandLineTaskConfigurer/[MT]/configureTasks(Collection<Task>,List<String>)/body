{
  List<String> unusedArguments=new LinkedList<String>(arguments);
  for (  Task task : tasks) {
    Map<String,JavaMethod<Object,?>> options=new HashMap<String,JavaMethod<Object,?>>();
    CommandLineParser parser=new CommandLineParser();
    for (Class<?> type=task.getClass(); type != Object.class; type=type.getSuperclass()) {
      for (      Method method : type.getDeclaredMethods()) {
        CommandLineOption commandLineOption=method.getAnnotation(CommandLineOption.class);
        if (commandLineOption != null) {
          String optionName=commandLineOption.options()[0];
          org.gradle.cli.CommandLineOption option=parser.option(optionName);
          option.hasDescription(commandLineOption.description());
          if (method.getParameterTypes().length > 0 && !hasSingleBooleanParameter(method)) {
            option.hasArgument();
          }
          options.put(optionName,JavaMethod.create(Object.class,Object.class,method));
        }
      }
    }
    ParsedCommandLine parsed=null;
    try {
      parsed=parser.parse(arguments);
    }
 catch (    CommandLineArgumentException e) {
      throw new GradleException("Problem configuring task " + task.getPath() + " from command line. "+ e.getMessage(),e);
    }
    for (    Map.Entry<String,JavaMethod<Object,?>> entry : options.entrySet()) {
      if (parsed.hasOption(entry.getKey())) {
        ParsedCommandLineOption o=parsed.option(entry.getKey());
        if (o.hasValue()) {
          entry.getValue().invoke(task,o.getValue());
        }
 else {
          entry.getValue().invoke(task,true);
        }
      }
    }
    unusedArguments.retainAll(parsed.getExtraArguments());
  }
  return unusedArguments;
}
