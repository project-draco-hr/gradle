{
  validateType(type);
  List<Method> methodList=Arrays.asList(type.getDeclaredMethods());
  if (methodList.isEmpty()) {
    return new ModelSchema<T>(type,Collections.<ModelProperty<?>>emptyList());
  }
  List<ModelProperty<?>> properties=Lists.newLinkedList();
  Map<String,Method> methods=Maps.newHashMap();
  for (  Method method : methodList) {
    String name=method.getName();
    if (methods.containsKey(name)) {
      throw invalidMethod(type,name,"overloaded methods are not supported");
    }
    methods.put(name,method);
  }
  List<String> methodNames=Lists.newLinkedList(methods.keySet());
  List<String> handled=Lists.newArrayList();
  for (ListIterator<String> iterator=methodNames.listIterator(); iterator.hasNext(); ) {
    String methodName=iterator.next();
    Method method=methods.get(methodName);
    if (methodName.startsWith("get") && !methodName.equals("get")) {
      if (method.getParameterTypes().length != 0) {
        throw invalidMethod(type,methodName,"getter methods cannot take parameters");
      }
      Character getterPropertyNameFirstChar=methodName.charAt(3);
      if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
        throw invalidMethod(type,methodName,"the 4th character of the getter method name must be an uppercase character");
      }
      Class<?> returnType=method.getReturnType();
      ModelType<?> returnModelType=ModelType.of(returnType);
      if (returnType.equals(String.class)) {
        properties.add(extractNonManagedProperty(type,methods,methodName,returnModelType,handled));
      }
 else       if (isManaged(returnType)) {
        properties.add(extractManagedProperty(type,methods,methodName,returnModelType,handled));
      }
 else {
        throw invalidMethod(type,methodName,"only String and managed properties are supported");
      }
      iterator.remove();
    }
  }
  methodNames.removeAll(handled);
  if (!methodNames.isEmpty()) {
    throw invalid(type,"only paired getter/setter methods are supported (invalid methods: [" + Joiner.on(", ").join(methodNames) + "])");
  }
  return new ModelSchema<T>(type,properties);
}
