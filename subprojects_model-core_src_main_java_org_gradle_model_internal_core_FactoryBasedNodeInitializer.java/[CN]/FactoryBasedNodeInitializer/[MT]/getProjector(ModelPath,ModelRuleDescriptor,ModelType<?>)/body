{
  if (!type.isAssignableFrom(typeToCreate)) {
    throw new IllegalArgumentException(String.format("Type %s is not a subtype of %s",typeToCreate,type));
  }
  final ModelType<? extends S> projectedType=Cast.uncheckedCast(typeToCreate);
  return new ModelProjector(){
    @Override public ModelRuleDescriptor getDescriptor(){
      return descriptor;
    }
    @Override public ModelPath getPath(){
      return path;
    }
    @Override public Set<? extends ModelProjection> getProjections(    MutableModelNode node,    List<ModelView<?>> inputs){
      InstanceFactory<S,String> factory=Cast.uncheckedCast(inputs.get(0).getInstance());
      Set<ModelType<? extends S>> internalViews=factory.getInternalViews(projectedType);
      return ImmutableSet.copyOf(Iterables.transform(internalViews,new Function<ModelType<?>,ModelProjection>(){
        @Override public ModelProjection apply(        ModelType<?> internalView){
          return UnmanagedModelProjection.of(internalView);
        }
      }
));
    }
    @Override public List<ModelReference<?>> getInputs(){
      return Collections.<ModelReference<?>>singletonList(factoryReference);
    }
  }
;
}
