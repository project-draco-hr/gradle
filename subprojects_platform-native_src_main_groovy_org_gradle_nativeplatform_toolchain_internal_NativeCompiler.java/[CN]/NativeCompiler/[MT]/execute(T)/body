{
  final T transformedSpec=specTransformer.transform(spec);
  CompileSpecToArgsTransformerChain<T> chain=new CompileSpecToArgsTransformerChain<T>(argsTransformer);
  if (useCommandFile) {
    chain.withTransformation(optionsFileTransformer(transformedSpec));
  }
  ArgsTransformer<T> genericArgTransformer=new ShortCircuitArgsTransformer<T>(chain);
  genericArgTransformer.transform(transformedSpec);
  final StoppableExecutor executor;
  if (useParallelCompile()) {
    executor=new DefaultExecutorFactory().create(commandLineTool.getDisplayName());
  }
 else {
    executor=new CallingThreadExecutor();
  }
  boolean windowsPathLimitation=OperatingSystem.current().isWindows();
  for (  File sourceFile : transformedSpec.getSourceFiles()) {
    CompileSpecToArgsTransformerChain<T> perFileChain=new CompileSpecToArgsTransformerChain<T>(genericArgTransformer);
    perFileChain.withTransformation(new SingleSourceCompileArgTransformer(sourceFile));
    perFileChain.withTransformation(outputFileTransformer(sourceFile,spec.getObjectFileDir(),objectFileSuffix,windowsPathLimitation));
    MutableCommandLineToolInvocation perFileInvocation=baseInvocation.copy();
    perFileInvocation.clearPostArgsActions();
    perFileInvocation.setWorkDirectory(transformedSpec.getObjectFileDir());
    perFileInvocation.setArgs(perFileChain.transform(transformedSpec));
    executor.execute(commandLineTool.toRunnableExecution(perFileInvocation));
  }
  executor.stop();
  return new SimpleWorkResult(!transformedSpec.getSourceFiles().isEmpty());
}
