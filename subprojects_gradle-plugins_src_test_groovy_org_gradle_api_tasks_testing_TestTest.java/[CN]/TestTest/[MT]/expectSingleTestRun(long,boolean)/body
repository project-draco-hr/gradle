{
  expectOptionsBuilt();
  context.checking(new Expectations(){
{
      allowing(classpathMock).iterator();
      will(returnIterator(new File("classpath.jar")));
      one(testFrameworkInstanceMock).getProcessorFactory();
      will(returnValue(testProcessorFactoryMock));
      one(testClassScannerFactoryMock).createTestClassScanner(with(sameInstance(test)),with(notNullValue(TestClassProcessor.class)),with(notNullValue(TestListenerAdapter.class)));
      will(returnValue(testClassScannerMock));
      final TestResult result=context.mock(TestResult.class);
      allowing(result).getTestCount();
      will(returnValue(testCount));
      ignoring(result);
      final TestDescriptor testDescriptor=context.mock(TestDescriptor.class);
      allowing(testDescriptor).getName();
      will(returnValue("test"));
      allowing(testDescriptor).getParent();
      will(returnValue(null));
      ignoring(testDescriptor);
      one(testClassScannerMock).run();
      will(new Action(){
        public void describeTo(        Description description){
          description.appendText("fail tests");
        }
        public Object invoke(        Invocation invocation) throws Throwable {
          TestTest.this.test.getTestListenerBroadcaster().getSource().beforeSuite(testDescriptor);
          TestTest.this.test.getTestListenerBroadcaster().getSource().afterSuite(testDescriptor,result);
          return null;
        }
      }
);
      if (expectReport) {
        one(testFrameworkInstanceMock).report();
      }
    }
  }
);
}
