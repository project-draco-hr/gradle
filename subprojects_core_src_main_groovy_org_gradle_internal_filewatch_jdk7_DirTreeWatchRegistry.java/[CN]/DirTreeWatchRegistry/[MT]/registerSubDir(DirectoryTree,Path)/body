{
  final Spec<FileTreeElement> excludeSpec=tree.getPatterns().getAsExcludeSpec();
  final Spec<FileTreeElement> fileSpec=tree.getPatterns().getAsSpec();
  final Path rootPath=dirToPath(tree.getDir());
  final AtomicBoolean containsValidFiles=new AtomicBoolean(false);
  walkFileTree(subRootPath,new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      FileTreeElement fileTreeElement=toFileTreeElement(dir,rootPath.relativize(dir));
      if (!excludeSpec.isSatisfiedBy(fileTreeElement)) {
        watchDirectory(dir);
        if (pathToDirectoryTree.containsKey(dir)) {
          throw new IllegalStateException("The current implementation doesn't support watching nested directory trees");
        }
        pathToDirectoryTree.put(dir,tree);
        return FileVisitResult.CONTINUE;
      }
 else {
        return FileVisitResult.SKIP_SUBTREE;
      }
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      FileTreeElement fileTreeElement=toFileTreeElement(file,rootPath.relativize(file));
      if (!containsValidFiles.get() && fileSpec.isSatisfiedBy(fileTreeElement)) {
        containsValidFiles.set(true);
      }
      return FileVisitResult.CONTINUE;
    }
  }
);
  return containsValidFiles.get();
}
