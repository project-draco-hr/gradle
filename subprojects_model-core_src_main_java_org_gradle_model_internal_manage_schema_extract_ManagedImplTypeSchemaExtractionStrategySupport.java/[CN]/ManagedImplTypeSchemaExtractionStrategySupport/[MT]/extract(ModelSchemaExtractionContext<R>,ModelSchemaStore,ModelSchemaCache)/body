{
  ModelType<R> type=extractionContext.getType();
  Class<? super R> clazz=type.getRawClass();
  if (isTarget(type)) {
    validateType(type,extractionContext);
    Iterable<Method> methods=getManagedMethods(clazz);
    ImmutableListMultimap<String,Method> methodsByName=Multimaps.index(methods,new Function<Method,String>(){
      public String apply(      Method method){
        return method.getName();
      }
    }
);
    ensureNoOverloadedMethods(extractionContext,methodsByName);
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    List<Method> handled=Lists.newArrayListWithCapacity(clazz.getMethods().length);
    ReturnTypeSpecializationOrdering returnTypeSpecializationOrdering=new ReturnTypeSpecializationOrdering();
    for (    String methodName : methodsByName.keySet()) {
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        ImmutableList<Method> getterMethods=methodsByName.get(methodName);
        Method sampleMethod=returnTypeSpecializationOrdering.max(getterMethods);
        boolean abstractGetter=Modifier.isAbstract(sampleMethod.getModifiers());
        if (sampleMethod.getParameterTypes().length != 0) {
          throw invalidMethod(extractionContext,"getter methods cannot take parameters",sampleMethod);
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,"the 4th character of the getter method name must be an uppercase character",sampleMethod);
        }
        ModelType<?> returnType=ModelType.returnType(sampleMethod);
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        ImmutableList<Method> setterMethods=methodsByName.get(setterName);
        boolean isWritable=!setterMethods.isEmpty();
        if (isWritable) {
          Method setter=setterMethods.get(0);
          if (!abstractGetter) {
            throw invalidMethod(extractionContext,"setters are not allowed for non-abstract getters",setter);
          }
          validateSetter(extractionContext,returnType,setter);
          handled.addAll(setterMethods);
        }
        if (abstractGetter) {
          ImmutableSet<ModelType<?>> declaringClasses=ImmutableSet.copyOf(Iterables.transform(getterMethods,new Function<Method,ModelType<?>>(){
            public ModelType<?> apply(            Method input){
              return ModelType.of(input.getDeclaringClass());
            }
          }
));
          Map<Class<? extends Annotation>,Annotation> annotations=Maps.newLinkedHashMap();
          for (          Method getterMethod : getterMethods) {
            for (            Annotation annotation : getterMethod.getDeclaredAnnotations()) {
              if (!annotations.containsKey(annotation.annotationType())) {
                annotations.put(annotation.annotationType(),annotation);
              }
            }
          }
          properties.add(ModelProperty.of(returnType,propertyName,isWritable,declaringClasses,annotations));
        }
        handled.addAll(getterMethods);
      }
    }
    Iterable<Method> notHandled=Iterables.filter(methodsByName.values(),Predicates.not(Predicates.in(handled)));
    if (!Iterables.isEmpty(notHandled)) {
      throw invalidMethods(extractionContext,"only paired getter/setter methods are supported",notHandled);
    }
    Class<R> concreteClass=type.getConcreteClass();
    final ModelSchema<R> schema=createSchema(extractionContext,store,type,properties,concreteClass);
    Iterable<ModelSchemaExtractionContext<?>> propertyDependencies=Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toPropertyExtractionContext(extractionContext,property,cache);
      }
    }
);
    return new ModelSchemaExtractionResult<R>(schema,propertyDependencies);
  }
 else {
    return null;
  }
}
