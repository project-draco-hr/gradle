{
  return parentContext.child(property.getType(),propertyDescription(parentContext,property),new Action<ModelSchemaExtractionContext<P>>(){
    public void execute(    ModelSchemaExtractionContext<P> propertyExtractionContext){
      if (!property.isManaged()) {
        return;
      }
      ModelSchema<P> propertySchema=modelSchemaCache.get(property.getType());
      if (property.getName().equals("name") && Named.class.isAssignableFrom(parentContext.getType().getRawClass())) {
        if (property.isWritable()) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("@Managed types implementing %s must not declare a setter for the name property",Named.class.getName()));
        }
 else {
          return;
        }
      }
      boolean isDeclaredAsHavingUnmanagedType=property.isAnnotationPresent(Unmanaged.class);
      if (propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && isDeclaredAsHavingUnmanagedType) {
        throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' is marked as @Unmanaged, but is of @Managed type '%s'. Please remove the @Managed annotation.%n",property.getName(),property.getType()));
      }
      if (!propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && !isDeclaredAsHavingUnmanagedType) {
        throw new InvalidManagedModelElementTypeException(parentContext,String.format("type %s cannot be used for property '%s' as it is an unmanaged type (please annotate the getter with @org.gradle.model.Unmanaged if you want this property to be unmanaged).%n%s",property.getType(),property.getName(),ModelSchemaExtractor.getManageablePropertyTypesDescription()));
      }
      if (!property.isWritable()) {
        if (isDeclaredAsHavingUnmanagedType) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("unmanaged property '%s' cannot be read only, unmanaged properties must have setters",property.getName()));
        }
        if (!propertySchema.getKind().isManaged()) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("read only property '%s' has non managed type %s, only managed types can be used",property.getName(),property.getType()));
        }
      }
      if (propertySchema.getKind() == ModelSchema.Kind.COLLECTION) {
        if (property.isWritable()) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot have a setter (%s properties must be read only).",property.getName(),property.getType().toString()));
        }
        ModelCollectionSchema<P,?> propertyCollectionsSchema=(ModelCollectionSchema<P,?>)propertySchema;
        ModelType<?> elementType=propertyCollectionsSchema.getElementType();
        ModelSchema<?> elementTypeSchema=modelSchemaCache.get(elementType);
        if (!elementTypeSchema.getKind().isManaged()) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot be a model map of type %s as it is not a %s type.",property.getName(),elementType,Managed.class.getName()));
        }
      }
    }
  }
);
}
