{
  BuildResult<?> result=buildModels(elementType,operationParameters);
  if (result.getModel() instanceof List) {
    ExceptionTransformer exceptionTransformer=new ExceptionTransformer(new Transformer<String,Throwable>(){
      @Override public String transform(      Throwable throwable){
        return String.format("Could not fetch models of type '%s' using Gradle daemon composite connection.",elementType.getSimpleName());
      }
    }
);
    final List<ModelResult<T>> models=new LinkedList<ModelResult<T>>();
    List resultMap=(List)result.getModel();
    for (    Object modelValueTriple : resultMap) {
      Object[] t=(Object[])modelValueTriple;
      ProjectIdentifier projectIdentifier=new DefaultProjectIdentifier((File)t[0],(String)t[1]);
      Object modelValue=t[2];
      if (modelValue instanceof Throwable) {
        GradleConnectionException failure=exceptionTransformer.transform((Throwable)modelValue);
        models.add(new DefaultFailedModelResult<T>(projectIdentifier,failure));
      }
 else {
        T modelResult=adapter.adapt(elementType,modelValue,getCompatibilityMapperAction(projectIdentifier));
        models.add(new DefaultModelResult<T>(modelResult));
      }
    }
    return models;
  }
  throw new UnsupportedOperationException(String.format("Produced result of type %s for model %s",result.getModel().getClass().getCanonicalName(),elementType.getCanonicalName()));
}
