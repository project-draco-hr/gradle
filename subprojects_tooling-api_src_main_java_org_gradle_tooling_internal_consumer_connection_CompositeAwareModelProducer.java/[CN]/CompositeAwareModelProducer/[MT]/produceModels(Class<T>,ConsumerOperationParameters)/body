{
  BuildResult<?> result=buildModels(elementType,operationParameters);
  if (result.getModel() instanceof Map) {
    ExceptionTransformer exceptionTransformer=new ExceptionTransformer(new Transformer<String,Throwable>(){
      @Override public String transform(      Throwable throwable){
        return String.format("Could not fetch models of type '%s' using Gradle daemon composite connection.",elementType.getSimpleName());
      }
    }
);
    final List<ModelResult<T>> models=new LinkedList<ModelResult<T>>();
    Map<Object,Object> resultMap=(Map)result.getModel();
    for (    Map.Entry<Object,Object> entry : resultMap.entrySet()) {
      ProjectIdentity projectIdentity=adapter.adapt(ProjectIdentity.class,entry.getKey());
      if (entry.getValue() instanceof Throwable) {
        GradleConnectionException failure=exceptionTransformer.transform((Throwable)entry.getValue());
        models.add(new DefaultFailureModelResult<T>(projectIdentity,failure));
      }
 else {
        T modelResult=adapter.adapt(elementType,entry.getValue(),getCompatibilityMapperAction(projectIdentity));
        models.add(new DefaultModelResult<T>(modelResult));
      }
    }
    return models;
  }
  throw new UnsupportedOperationException(String.format("Produced result of type %s for model %s",result.getModel().getClass().getCanonicalName(),elementType.getCanonicalName()));
}
