{
  final Class<? extends Task> taskClazz=task.getClass();
  Map<String,OptionDescriptor> options=new HashMap<String,OptionDescriptor>();
  if (!cachedStaticDescriptors.containsKey(task.getClass())) {
    for (Class<?> type=taskClazz; type != Object.class && type != null; type=type.getSuperclass()) {
      for (      Method method : type.getDeclaredMethods()) {
        if (!Modifier.isStatic(method.getModifiers())) {
          Option option=method.getAnnotation(Option.class);
          if (option != null) {
            StaticOptionDescriptor staticCommandLineOptionDescriptor=new StaticOptionDescriptor(option,method);
            assertMethodTypeSupported(staticCommandLineOptionDescriptor,taskClazz,method);
            OptionDescriptor optionDescriptor=new InstanceOptionDescriptor(task,staticCommandLineOptionDescriptor);
            if (options.containsKey(optionDescriptor.getName())) {
              throw new CommandLineArgumentException(String.format("Option '%s' linked to multiple methods in class '%s'.",optionDescriptor.getName(),taskClazz.getName()));
            }
            cachedStaticDescriptors.put(taskClazz,staticCommandLineOptionDescriptor);
            options.put(optionDescriptor.getName(),optionDescriptor);
          }
        }
      }
    }
  }
 else {
    for (    StaticOptionDescriptor staticCommandLineOptionDescriptor : cachedStaticDescriptors.get(taskClazz)) {
      options.put(staticCommandLineOptionDescriptor.getName(),new InstanceOptionDescriptor(task,staticCommandLineOptionDescriptor));
    }
  }
  return CollectionUtils.sort(options.values());
}
