{
  List<ModelReference<?>> references=ruleDefinition.getReferences();
  if (references.isEmpty()) {
    problems.add(ruleDefinition,"A method annotated with @Model must either take at least one parameter or have a non-void return type");
    return;
  }
  ModelType<T> modelType=Cast.uncheckedCast(references.get(0).getType());
  final ModelSchema<T> modelSchema=getModelSchema(modelType,ruleDefinition);
  List<ModelReference<?>> bindings=ruleDefinition.getReferences();
  List<ModelReference<?>> inputs=bindings.subList(1,bindings.size());
  final ModelRuleDescriptor descriptor=ruleDefinition.getDescriptor();
  if (modelSchema instanceof SpecializedMapSchema) {
    registration.actions(SpecializedMapNodeInitializer.getActions(ModelReference.of(modelPath),descriptor,(SpecializedMapSchema<T,?>)modelSchema));
  }
 else {
    registration.action(ModelActionRole.Discover,Collections.singletonList(ModelReference.of(NodeInitializerRegistry.class)),new BiAction<MutableModelNode,List<ModelView<?>>>(){
      @Override public void execute(      MutableModelNode node,      List<ModelView<?>> modelViews){
        NodeInitializerRegistry nodeInitializerRegistry=(NodeInitializerRegistry)modelViews.get(0).getInstance();
        NodeInitializer initializer=getNodeInitializer(descriptor,modelSchema,nodeInitializerRegistry);
        for (        Map.Entry<ModelActionRole,ModelAction<?>> actionInRole : initializer.getActions(ModelReference.of(modelPath),descriptor).entries()) {
          ModelActionRole role=actionInRole.getKey();
          ModelAction<?> action=actionInRole.getValue();
          node.applyToSelf(role,action);
        }
      }
    }
);
  }
  registration.action(ModelActionRole.Initialize,InputUsingModelAction.of(ModelReference.of(modelPath,modelType),descriptor,inputs,new RuleMethodBackedMutationAction<T>(ruleDefinition.getRuleInvoker())));
}
