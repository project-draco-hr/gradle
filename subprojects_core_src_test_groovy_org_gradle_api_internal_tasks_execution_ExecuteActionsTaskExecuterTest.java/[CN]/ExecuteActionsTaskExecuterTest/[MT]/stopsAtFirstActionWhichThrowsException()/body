{
  final Throwable failure=new RuntimeException("failure");
  final Collector<Throwable> wrappedFailure=collector();
  context.checking(new Expectations(){
{
      allowing(task).getTaskActions();
      will(returnValue(toList(action1,action2)));
      oneOf(publicListener).beforeActions(task);
      inSequence(sequence);
      oneOf(internalListener).beforeTaskOutputsGenerated();
      inSequence(sequence);
      oneOf(state).setExecuting(true);
      inSequence(sequence);
      oneOf(state).setDidWork(true);
      inSequence(sequence);
      oneOf(standardOutputCapture).start();
      inSequence(sequence);
      oneOf(action1).contextualise(executionContext);
      inSequence(sequence);
      oneOf(action1).execute(task);
      will(throwException(failure));
      inSequence(sequence);
      oneOf(action1).contextualise(null);
      inSequence(sequence);
      oneOf(standardOutputCapture).stop();
      inSequence(sequence);
      oneOf(state).executed(with(notNullValue(Throwable.class)));
      will(collectTo(wrappedFailure));
      inSequence(sequence);
      oneOf(state).setExecuting(false);
      inSequence(sequence);
      oneOf(publicListener).afterActions(task);
      inSequence(sequence);
    }
  }
);
  executer.execute(task,state,executionContext);
  assertThat(wrappedFailure.get(),instanceOf(TaskExecutionException.class));
  TaskExecutionException exception=(TaskExecutionException)wrappedFailure.get();
  assertThat(exception.getTask(),equalTo((Task)task));
  assertThat(exception.getMessage(),equalTo("Execution failed for <task>."));
  assertThat(exception.getCause(),sameInstance(failure));
}
