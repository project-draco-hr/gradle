{
  ModelSchema<T> cached=cache.get(type);
  if (cached != null) {
    return cached;
  }
  validateType(type);
  List<Method> methodList=Arrays.asList(type.getRawClass().getDeclaredMethods());
  if (methodList.isEmpty()) {
    return new ModelSchema<T>(type,Collections.<ModelProperty<?>>emptyList());
  }
  List<ModelProperty<?>> properties=Lists.newLinkedList();
  Map<String,Method> methods=Maps.newHashMap();
  for (  Method method : methodList) {
    String name=method.getName();
    if (methods.containsKey(name)) {
      throw invalidMethod(type,name,"overloaded methods are not supported");
    }
    methods.put(name,method);
  }
  List<String> methodNames=Lists.newLinkedList(methods.keySet());
  List<String> handled=Lists.newArrayList();
  for (  String methodName : methodNames) {
    Method method=methods.get(methodName);
    if (methodName.startsWith("get") && !methodName.equals("get")) {
      if (method.getParameterTypes().length != 0) {
        throw invalidMethod(type,methodName,"getter methods cannot take parameters");
      }
      Character getterPropertyNameFirstChar=methodName.charAt(3);
      if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
        throw invalidMethod(type,methodName,"the 4th character of the getter method name must be an uppercase character");
      }
      ModelType<?> returnType=ModelType.of(method.getGenericReturnType());
      if (isManaged(returnType.getRawClass())) {
        properties.add(extractPropertyOfManagedType(cache,type,methods,methodName,returnType,handled));
      }
 else {
        properties.add(extractPropertyOfUnmanagedType(type,methods,methodName,returnType,handled));
      }
      handled.add(methodName);
    }
  }
  methodNames.removeAll(handled);
  if (!methodNames.isEmpty()) {
    throw invalid(type,"only paired getter/setter methods are supported (invalid methods: [" + Joiner.on(", ").join(methodNames) + "])");
  }
  ModelSchema<T> schema=new ModelSchema<T>(type,properties);
  cache.set(type,schema);
  return schema;
}
