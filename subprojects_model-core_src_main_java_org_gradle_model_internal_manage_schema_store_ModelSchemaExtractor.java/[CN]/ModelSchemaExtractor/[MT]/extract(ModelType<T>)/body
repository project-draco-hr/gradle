{
  validateType(type);
  List<Method> methodList=Arrays.asList(type.getRawClass().getDeclaredMethods());
  if (methodList.isEmpty()) {
    return new ExtractedModelSchema<T>(type,Collections.<ModelPropertyFactory<?>>emptyList());
  }
  List<ModelPropertyFactory<?>> propertyFactories=Lists.newLinkedList();
  Map<String,Method> methods=Maps.newHashMap();
  for (  Method method : methodList) {
    String name=method.getName();
    if (methods.containsKey(name)) {
      throw invalidMethod(type,name,"overloaded methods are not supported");
    }
    methods.put(name,method);
  }
  List<String> methodNames=Lists.newLinkedList(methods.keySet());
  List<String> handled=Lists.newArrayList();
  for (ListIterator<String> iterator=methodNames.listIterator(); iterator.hasNext(); ) {
    String methodName=iterator.next();
    Method method=methods.get(methodName);
    if (methodName.startsWith("get") && !methodName.equals("get")) {
      if (method.getParameterTypes().length != 0) {
        throw invalidMethod(type,methodName,"getter methods cannot take parameters");
      }
      Character getterPropertyNameFirstChar=methodName.charAt(3);
      if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
        throw invalidMethod(type,methodName,"the 4th character of the getter method name must be an uppercase character");
      }
      ModelType<?> returnType=ModelType.of(method.getGenericReturnType());
      if (isManaged(returnType.getRawClass())) {
        propertyFactories.add(extractPropertyOfManagedType(type,methods,methodName,returnType,handled));
      }
 else {
        propertyFactories.add(extractPropertyOfUnmanagedType(type,methods,methodName,returnType,handled));
      }
      iterator.remove();
    }
  }
  methodNames.removeAll(handled);
  if (!methodNames.isEmpty()) {
    throw invalid(type,"only paired getter/setter methods are supported (invalid methods: [" + Joiner.on(", ").join(methodNames) + "])");
  }
  return new ExtractedModelSchema<T>(type,propertyFactories);
}
