{
  final TaskHistory history=loadHistory(task);
  final LazyTaskExecution currentExecution=new LazyTaskExecution(history);
  currentExecution.snapshotRepository=snapshotRepository;
  currentExecution.cacheAccess=cacheAccess;
  currentExecution.setOutputFiles(outputFiles(task));
  final LazyTaskExecution previousExecution=findPreviousExecution(currentExecution,history);
  if (previousExecution != null) {
    previousExecution.snapshotRepository=snapshotRepository;
    previousExecution.cacheAccess=cacheAccess;
  }
  return new History(){
    public TaskExecution getPreviousExecution(){
      return previousExecution;
    }
    public TaskExecution getCurrentExecution(){
      return currentExecution;
    }
    public void update(){
      cacheAccess.useCache("Update task history",new Runnable(){
        public void run(){
          history.configurations.add(0,currentExecution);
          if (currentExecution.inputFilesSnapshotIds == null && currentExecution.inputFilesSnapshot != null) {
            ImmutableSortedMap.Builder<String,Long> builder=ImmutableSortedMap.naturalOrder();
            for (            Map.Entry<String,FileCollectionSnapshot> entry : currentExecution.inputFilesSnapshot.entrySet()) {
              builder.put(entry.getKey(),snapshotRepository.add(entry.getValue()));
            }
            currentExecution.inputFilesSnapshotIds=builder.build();
          }
          if (currentExecution.outputFilesSnapshotIds == null && currentExecution.outputFilesSnapshot != null) {
            ImmutableSortedMap.Builder<String,Long> builder=ImmutableSortedMap.naturalOrder();
            for (            Map.Entry<String,FileCollectionSnapshot> entry : currentExecution.outputFilesSnapshot.entrySet()) {
              builder.put(entry.getKey(),snapshotRepository.add(entry.getValue()));
            }
            currentExecution.outputFilesSnapshotIds=builder.build();
          }
          if (currentExecution.discoveredFilesSnapshotId == null && currentExecution.discoveredFilesSnapshot != null) {
            currentExecution.discoveredFilesSnapshotId=snapshotRepository.add(currentExecution.discoveredFilesSnapshot);
          }
          while (history.configurations.size() > TaskHistory.MAX_HISTORY_ENTRIES) {
            LazyTaskExecution execution=history.configurations.remove(history.configurations.size() - 1);
            if (execution.inputFilesSnapshotIds != null) {
              for (              Long id : execution.inputFilesSnapshotIds.values()) {
                snapshotRepository.remove(id);
              }
            }
            if (execution.outputFilesSnapshotIds != null) {
              for (              Long id : execution.outputFilesSnapshotIds.values()) {
                snapshotRepository.remove(id);
              }
            }
            if (execution.discoveredFilesSnapshotId != null) {
              snapshotRepository.remove(execution.discoveredFilesSnapshotId);
            }
          }
          history.beforeSerialized();
          taskHistoryCache.put(task.getPath(),history);
        }
      }
);
    }
    @Override public void finished(    boolean wasUpToDate){
      if (wasUpToDate && history.modified) {
        cacheAccess.useCache("Update task history",new Runnable(){
          public void run(){
            history.beforeSerialized();
            taskHistoryCache.put(task.getPath(),history);
          }
        }
);
      }
    }
  }
;
}
