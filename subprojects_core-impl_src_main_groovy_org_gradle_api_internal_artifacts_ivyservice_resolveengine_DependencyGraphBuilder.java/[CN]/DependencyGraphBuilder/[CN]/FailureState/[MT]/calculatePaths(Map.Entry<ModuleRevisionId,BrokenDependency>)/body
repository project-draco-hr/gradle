{
  Map<ConfigurationNode,List<ModuleRevisionId>> shortestPaths=new LinkedHashMap<ConfigurationNode,List<ModuleRevisionId>>();
  List<ModuleRevisionId> rootPath=new ArrayList<ModuleRevisionId>();
  rootPath.add(root.moduleRevision.id);
  shortestPaths.put(root,rootPath);
  Set<ConfigurationNode> seen=new HashSet<ConfigurationNode>();
  LinkedList<ConfigurationNode> queue=new LinkedList<ConfigurationNode>();
  queue.addAll(entry.getValue().requiredBy);
  while (!queue.isEmpty()) {
    ConfigurationNode node=queue.getFirst();
    if (node == root) {
      queue.removeFirst();
    }
 else     if (seen.add(node)) {
      for (      DependencyEdge dependencyEdge : node.incomingEdges) {
        queue.add(0,dependencyEdge.from);
      }
    }
 else {
      queue.remove();
      List<ModuleRevisionId> shortest=null;
      for (      DependencyEdge dependencyEdge : node.incomingEdges) {
        List<ModuleRevisionId> candidate=shortestPaths.get(dependencyEdge.from);
        if (candidate == null) {
          continue;
        }
        if (shortest == null) {
          shortest=candidate;
        }
 else         if (shortest.size() > candidate.size()) {
          shortest=candidate;
        }
      }
      if (shortest == null) {
        continue;
      }
      List<ModuleRevisionId> path=new ArrayList<ModuleRevisionId>();
      path.addAll(shortest);
      path.add(node.moduleRevision.id);
      shortestPaths.put(node,path);
    }
  }
  List<List<ModuleRevisionId>> paths=new ArrayList<List<ModuleRevisionId>>();
  for (  ConfigurationNode node : entry.getValue().requiredBy) {
    paths.add(shortestPaths.get(node));
  }
  return paths;
}
