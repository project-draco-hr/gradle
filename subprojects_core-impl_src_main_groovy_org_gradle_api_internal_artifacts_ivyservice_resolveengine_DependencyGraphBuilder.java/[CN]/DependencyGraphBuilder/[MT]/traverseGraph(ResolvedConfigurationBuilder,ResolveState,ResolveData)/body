{
  SetMultimap<ModuleRevisionId,DependencyResolvePath> conflicts=LinkedHashMultimap.create();
  List<DependencyResolvePath> queue=new ArrayList<DependencyResolvePath>();
  resolveState.root.addOutgoingDependencies(new RootPath(),queue);
  while (!queue.isEmpty() || !conflicts.isEmpty()) {
    if (!queue.isEmpty()) {
      DependencyResolvePath path=queue.remove(0);
      LOGGER.debug("Visiting path {}.",path);
      try {
        path.resolveModuleRevisionId(dependencyResolver,resolveState,versionMatcher);
        if (path.targetModuleRevision.status == Status.Conflict) {
          LOGGER.debug("Found a conflict. Park this path.");
          conflicts.put(path.targetModuleRevision.id,path);
          continue;
        }
        path.resolveMetaData(dependencyResolver,resolveState);
      }
 catch (      ModuleResolveException t) {
        result.addUnresolvedDependency(new DefaultUnresolvedDependency(path.dependency.descriptor.getDependencyRevisionId().toString(),t));
        continue;
      }
      path.addOutgoingDependencies(resolveData,resolveState,queue);
    }
 else {
      ModuleId moduleId=conflicts.keySet().iterator().next().getModuleId();
      Set<ModuleRevisionResolveState> candidates=resolveState.getRevisions(moduleId);
      ModuleRevisionResolveState selected=conflictResolver.select(candidates,resolveState.root.moduleRevision);
      LOGGER.debug("Selected {} from conflicting modules {}.",selected,candidates);
      selected.status=Status.Include;
      for (      DependencyResolvePath path : conflicts.removeAll(selected.id)) {
        queue.add(path);
      }
      for (      ModuleRevisionResolveState candidate : candidates) {
        if (candidate != selected) {
          candidate.status=Status.Evict;
          for (          DependencyResolvePath path : conflicts.removeAll(candidate.id)) {
            path.restart(selected,queue);
          }
          for (          DependencyResolvePath path : new LinkedHashSet<DependencyResolvePath>(candidate.incomingPaths)) {
            path.restart(selected,queue);
          }
        }
      }
    }
  }
}
