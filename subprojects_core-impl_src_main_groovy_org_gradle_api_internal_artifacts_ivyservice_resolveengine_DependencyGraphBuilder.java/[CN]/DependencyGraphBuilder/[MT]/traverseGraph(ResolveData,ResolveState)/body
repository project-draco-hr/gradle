{
  SetMultimap<DefaultModuleRevisionResolveState,ResolvePath> pendingConflictResolution=LinkedHashMultimap.create();
  SetMultimap<ModuleId,DefaultModuleRevisionResolveState> allVersions=LinkedHashMultimap.create();
  Set<ModuleId> conflicts=new LinkedHashSet<ModuleId>();
  List<ResolvePath> queue=new ArrayList<ResolvePath>();
  resolveState.root.addOutgoingDependencies(new RootPath(),resolveState,queue);
  while (!queue.isEmpty() || !pendingConflictResolution.isEmpty()) {
    if (!queue.isEmpty()) {
      ResolvePath path=queue.remove(0);
      LOGGER.debug("Visiting path {}.",path);
      try {
        path.resolveModuleRevisionId(dependencyResolver,resolveState);
        ModuleId moduleId=path.getModuleId();
        if (allVersions.put(moduleId,path.getTargetModuleRevision())) {
          Set<DefaultModuleRevisionResolveState> versions=allVersions.get(moduleId);
          if (versions.size() == 1) {
            LOGGER.debug("Selecting new module version {}.",path.getTargetModuleRevision());
            resolveState.select(path.getTargetModuleRevision());
          }
 else {
            LOGGER.debug("Found new conflicting module version {}.",path.getTargetModuleRevision());
            conflicts.add(moduleId);
            resolveState.clearSelection(moduleId);
            Iterator<ResolvePath> iter=queue.iterator();
            while (iter.hasNext()) {
              ResolvePath resolvePath=iter.next();
              DefaultModuleRevisionResolveState conflict=resolvePath.traverses(versions);
              if (conflict != null) {
                LOGGER.debug("Queued path {} traverses version {} with conflicts. Parking this path.",resolvePath,conflict);
                iter.remove();
                pendingConflictResolution.put(conflict,resolvePath);
              }
            }
          }
        }
        if (conflicts.contains(moduleId)) {
          LOGGER.debug("Path refers to module {} with conflicts. Parking this path",moduleId);
          pendingConflictResolution.put(path.getTargetModuleRevision(),path);
          continue;
        }
        DefaultModuleRevisionResolveState selectedVersion=resolveState.getSelected(moduleId);
        if (selectedVersion != path.getTargetModuleRevision()) {
          LOGGER.debug("Version has been evicted. Restarting with target {}.",selectedVersion);
          queue.add(0,path.restart(resolveState,selectedVersion));
          continue;
        }
        path.resolveMetaData(resolveState);
      }
 catch (      ModuleVersionResolveException t) {
        continue;
      }
      path.addOutgoingDependencies(resolveData,resolveState,queue);
    }
 else {
      ModuleId moduleId=conflicts.iterator().next();
      conflicts.remove(moduleId);
      Set<DefaultModuleRevisionResolveState> candidates=allVersions.get(moduleId);
      DefaultModuleRevisionResolveState selected=conflictResolver.select(candidates,resolveState.root.moduleRevision);
      LOGGER.debug("Selected {} from conflicting modules {}.",selected,candidates);
      resolveState.select(selected);
      for (      ResolvePath path : pendingConflictResolution.removeAll(selected)) {
        queue.add(path.restart(resolveState,candidates,selected));
      }
      for (      DefaultModuleRevisionResolveState candidate : candidates) {
        if (candidate != selected) {
          for (          ResolvePath path : pendingConflictResolution.removeAll(candidate)) {
            queue.add(path.restart(resolveState,candidates,selected));
          }
          for (          DependencyResolvePath path : new LinkedHashSet<DependencyResolvePath>(candidate.incomingPaths)) {
            queue.add(path.restart(resolveState,candidates,selected));
          }
        }
      }
    }
  }
}
