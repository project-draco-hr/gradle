{
  if (delegateSchema != null && Modifier.isAbstract(delegateSchema.getType().getConcreteClass().getModifiers())) {
    throw new IllegalArgumentException(String.format("Delegate '%s' type must be null or a non-abstract type",delegateSchema.getType()));
  }
  ImmutableSet.Builder<WeaklyTypeReferencingMethod<?,?>> allViewMethodsBuilder=ImmutableSet.builder();
  StructSchema<T> publicStructSchema=Cast.uncheckedCast(publicSchema);
  allViewMethodsBuilder.addAll(publicStructSchema.getAllMethods());
  for (  StructSchema<?> internalViewSchema : internalViewSchemas) {
    allViewMethodsBuilder.addAll(internalViewSchema.getAllMethods());
  }
  Set<WeaklyTypeReferencingMethod<?,?>> viewMethods=allViewMethodsBuilder.build();
  Map<Wrapper<Method>,WeaklyTypeReferencingMethod<?,?>> delegateMethods;
  if (delegateSchema == null) {
    delegateMethods=Collections.emptyMap();
  }
 else {
    delegateMethods=Maps.uniqueIndex(delegateSchema.getAllMethods(),new Function<WeaklyTypeReferencingMethod<?,?>,Wrapper<Method>>(){
      @Override public Wrapper<Method> apply(      WeaklyTypeReferencingMethod<?,?> weakMethod){
        return METHOD_EQUIVALENCE.wrap(weakMethod.getMethod());
      }
    }
);
  }
  Multimap<String,AbstractStructMethodBinding> propertyMethodBindings=ArrayListMultimap.create();
  ImmutableSet.Builder<DirectMethodBinding> viewBindingsBuilder=ImmutableSet.builder();
  ImmutableSet.Builder<DelegateMethodBinding> delegateBindingsBuilder=ImmutableSet.builder();
  for (  WeaklyTypeReferencingMethod<?,?> weakViewMethod : viewMethods) {
    Method viewMethod=weakViewMethod.getMethod();
    PropertyAccessorType accessorType=PropertyAccessorType.of(viewMethod);
    WeaklyTypeReferencingMethod<?,?> weakDelegateMethod=delegateMethods.get(METHOD_EQUIVALENCE.wrap(viewMethod));
    AbstractStructMethodBinding binding;
    if (!Modifier.isAbstract(viewMethod.getModifiers())) {
      if (weakDelegateMethod != null) {
        throw new IllegalArgumentException(String.format("Method '%s' is both implemented by the view and the delegate type '%s'",viewMethod.toGenericString(),weakDelegateMethod.getMethod().toGenericString()));
      }
      DirectMethodBinding directBinding=new DirectMethodBinding(weakViewMethod);
      viewBindingsBuilder.add(directBinding);
      binding=directBinding;
    }
 else     if (weakDelegateMethod != null) {
      binding=new DelegateMethodBinding(weakViewMethod,weakDelegateMethod);
      delegateBindingsBuilder.add((DelegateMethodBinding)binding);
    }
 else     if (accessorType != null) {
      binding=new ManagedPropertyMethodBinding(weakViewMethod,accessorType);
    }
 else {
      if (delegateSchema == null) {
        throw new IllegalArgumentException(String.format("Method '%s' is not a property accessor, and it has no implementation",viewMethod.toGenericString()));
      }
 else {
        throw new IllegalArgumentException(String.format("Method '%s' is not a property accessor, and it has no implementation or a delegate in type '%s'",viewMethod.toGenericString(),delegateSchema.getType().getDisplayName()));
      }
    }
    if (accessorType != null) {
      propertyMethodBindings.put(accessorType.propertyNameFor(viewMethod),binding);
    }
  }
  ImmutableSortedMap.Builder<String,ManagedProperty> generatedPropertiesBuilder=ImmutableSortedMap.naturalOrder();
  for (  Map.Entry<String,Collection<AbstractStructMethodBinding>> entry : propertyMethodBindings.asMap().entrySet()) {
    String propertyName=entry.getKey();
    Collection<AbstractStructMethodBinding> bindings=entry.getValue();
    Iterator<AbstractStructMethodBinding> iBinding=bindings.iterator();
    Class<? extends AbstractStructMethodBinding> allBindingsType=iBinding.next().getClass();
    while (iBinding.hasNext()) {
      Class<? extends AbstractStructMethodBinding> bindingType=iBinding.next().getClass();
      if (!bindingType.equals(allBindingsType)) {
        throw new IllegalArgumentException(String.format("The accessor methods belonging to property '%s' should either all have an implementation in the view," + " be provided all by the default implementation, or they should all be without an implementation completely.",propertyName));
      }
    }
    if (allBindingsType == ManagedPropertyMethodBinding.class) {
      boolean foundGetter=false;
      boolean foundSetter=false;
      ImmutableMap.Builder<PropertyAccessorType,WeaklyTypeReferencingMethod<?,?>> accessorsBuilder=ImmutableMap.builder();
      ModelType<?> propertyType=null;
      for (      AbstractStructMethodBinding binding : bindings) {
        ManagedPropertyMethodBinding propertyBinding=(ManagedPropertyMethodBinding)binding;
        PropertyAccessorType accessorType=propertyBinding.getAccessorType();
        if (accessorType == PropertyAccessorType.SETTER) {
          foundSetter=true;
        }
 else {
          foundGetter=true;
        }
        WeaklyTypeReferencingMethod<?,?> accessor=propertyBinding.getSource();
        accessorsBuilder.put(accessorType,accessor);
        if (propertyType == null) {
          propertyType=accessorType.propertyTypeFor(accessor.getMethod());
        }
 else         if (!propertyType.equals(accessorType.propertyTypeFor(accessor.getMethod()))) {
          throw new IllegalStateException(String.format("Managed property '%s' must have a consistent type.",propertyName));
        }
      }
      if (foundSetter && !foundGetter) {
        throw new IllegalArgumentException(String.format("Managed property '%s' must both have an abstract getter as well as a setter.",propertyName));
      }
      ManagedProperty managedProperty=new ManagedProperty(propertyName,propertyType,!publicSchema.hasProperty(propertyName),accessorsBuilder.build());
      generatedPropertiesBuilder.put(propertyName,managedProperty);
    }
  }
  return new DefaultStructBindings<T>(publicStructSchema,internalViewSchemas,delegateSchema,generatedPropertiesBuilder.build(),viewBindingsBuilder.build(),delegateBindingsBuilder.build());
}
