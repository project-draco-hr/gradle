{
  if (delegateType != null && Modifier.isAbstract(delegateType.getConcreteClass().getModifiers())) {
    throw new IllegalArgumentException(String.format("Delegate '%s' type must be null or a non-abstract type",delegateType));
  }
  StructSchema<T> publicSchema=getStructSchema(publicType);
  Iterable<StructSchema<?>> internalViewSchemas=getStructSchemas(internalViewTypes);
  StructSchema<?> delegateSchema=delegateType == null ? null : getStructSchema(delegateType);
  ImmutableSet.Builder<WeaklyTypeReferencingMethod<?,?>> allViewMethodsBuilder=ImmutableSet.builder();
  StructSchema<T> publicStructSchema=Cast.uncheckedCast(publicSchema);
  allViewMethodsBuilder.addAll(publicStructSchema.getAllMethods());
  for (  StructSchema<?> internalViewSchema : internalViewSchemas) {
    allViewMethodsBuilder.addAll(internalViewSchema.getAllMethods());
  }
  Set<WeaklyTypeReferencingMethod<?,?>> viewMethods=allViewMethodsBuilder.build();
  Map<Wrapper<Method>,WeaklyTypeReferencingMethod<?,?>> delegateMethods;
  if (delegateSchema == null) {
    delegateMethods=Collections.emptyMap();
  }
 else {
    delegateMethods=Maps.uniqueIndex(delegateSchema.getAllMethods(),new Function<WeaklyTypeReferencingMethod<?,?>,Wrapper<Method>>(){
      @Override public Wrapper<Method> apply(      WeaklyTypeReferencingMethod<?,?> weakMethod){
        return METHOD_EQUIVALENCE.wrap(weakMethod.getMethod());
      }
    }
);
  }
  Multimap<String,AbstractStructMethodBinding> propertyMethodBindings=ArrayListMultimap.create();
  ImmutableSet.Builder<DirectMethodBinding> viewBindingsBuilder=ImmutableSet.builder();
  ImmutableSet.Builder<DelegateMethodBinding> delegateBindingsBuilder=ImmutableSet.builder();
  for (  WeaklyTypeReferencingMethod<?,?> weakViewMethod : viewMethods) {
    Method viewMethod=weakViewMethod.getMethod();
    PropertyAccessorType accessorType=PropertyAccessorType.of(viewMethod);
    WeaklyTypeReferencingMethod<?,?> weakDelegateMethod=delegateMethods.get(METHOD_EQUIVALENCE.wrap(viewMethod));
    AbstractStructMethodBinding binding;
    if (!Modifier.isAbstract(viewMethod.getModifiers())) {
      if (weakDelegateMethod != null) {
        throw new IllegalArgumentException(String.format("Method '%s' is both implemented by the view and the delegate type '%s'",viewMethod.toGenericString(),weakDelegateMethod.getMethod().toGenericString()));
      }
      DirectMethodBinding directBinding=new DirectMethodBinding(weakViewMethod);
      viewBindingsBuilder.add(directBinding);
      binding=directBinding;
    }
 else     if (weakDelegateMethod != null) {
      binding=new DelegateMethodBinding(weakViewMethod,weakDelegateMethod);
      delegateBindingsBuilder.add((DelegateMethodBinding)binding);
    }
 else     if (accessorType != null) {
      binding=new ManagedPropertyMethodBinding(weakViewMethod,accessorType);
    }
 else {
      if (delegateSchema == null) {
        throw new IllegalArgumentException(String.format("Method '%s' is not a property accessor, and it has no implementation",viewMethod.toGenericString()));
      }
 else {
        throw new IllegalArgumentException(String.format("Method '%s' is not a property accessor, and it has no implementation or a delegate in type '%s'",viewMethod.toGenericString(),delegateSchema.getType().getDisplayName()));
      }
    }
    if (accessorType != null) {
      propertyMethodBindings.put(accessorType.propertyNameFor(viewMethod),binding);
    }
  }
  ImmutableSortedMap.Builder<String,ManagedProperty<?>> generatedPropertiesBuilder=ImmutableSortedMap.naturalOrder();
  for (  Map.Entry<String,Collection<AbstractStructMethodBinding>> entry : propertyMethodBindings.asMap().entrySet()) {
    String propertyName=entry.getKey();
    Collection<AbstractStructMethodBinding> bindings=entry.getValue();
    Iterator<AbstractStructMethodBinding> iBinding=bindings.iterator();
    Class<? extends AbstractStructMethodBinding> allBindingsType=iBinding.next().getClass();
    while (iBinding.hasNext()) {
      Class<? extends AbstractStructMethodBinding> bindingType=iBinding.next().getClass();
      if (!bindingType.equals(allBindingsType)) {
        throw new IllegalArgumentException(String.format("The accessor methods belonging to property '%s' should either all have an implementation in the view," + " be provided all by the default implementation, or they should all be without an implementation completely.",propertyName));
      }
    }
    if (allBindingsType == ManagedPropertyMethodBinding.class) {
      boolean foundGetter=false;
      boolean foundSetter=false;
      EnumMap<PropertyAccessorType,WeaklyTypeReferencingMethod<?,?>> accessors=Maps.newEnumMap(PropertyAccessorType.class);
      Set<ModelType<?>> potentialPropertyTypes=Sets.newLinkedHashSet();
      for (      AbstractStructMethodBinding binding : bindings) {
        ManagedPropertyMethodBinding propertyBinding=(ManagedPropertyMethodBinding)binding;
        PropertyAccessorType accessorType=propertyBinding.getAccessorType();
        if (accessorType == PropertyAccessorType.SETTER) {
          foundSetter=true;
        }
 else {
          foundGetter=true;
        }
        WeaklyTypeReferencingMethod<?,?> accessor=propertyBinding.getSource();
        accessors.put(accessorType,accessor);
        potentialPropertyTypes.add(accessorType.propertyTypeFor(accessor.getMethod()));
      }
      if (foundSetter && !foundGetter) {
        throw new IllegalArgumentException(String.format("Managed property '%s' must both have an abstract getter as well as a setter.",propertyName));
      }
      Collection<ModelType<?>> convergingPropertyTypes=findConvergingTypes(potentialPropertyTypes);
      if (convergingPropertyTypes.size() != 1) {
        throw new IllegalArgumentException(String.format("Managed property '%s' must have a consistent type, but it's defined as %s.",propertyName,Joiner.on(", ").join(ModelType.getDisplayNames(convergingPropertyTypes))));
      }
      ModelType<?> propertyType=Iterables.getOnlyElement(convergingPropertyTypes);
      ManagedProperty<?> managedProperty=createProperty(propertyName,propertyType,!publicSchema.hasProperty(propertyName),accessors);
      generatedPropertiesBuilder.put(propertyName,managedProperty);
    }
  }
  return new DefaultStructBindings<T>(publicStructSchema,internalViewSchemas,delegateSchema,generatedPropertiesBuilder.build(),viewBindingsBuilder.build(),delegateBindingsBuilder.build());
}
