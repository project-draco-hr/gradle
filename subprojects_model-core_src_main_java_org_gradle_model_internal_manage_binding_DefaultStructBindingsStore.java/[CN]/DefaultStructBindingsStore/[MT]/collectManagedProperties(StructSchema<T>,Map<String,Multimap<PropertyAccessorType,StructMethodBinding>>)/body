{
  ImmutableSortedMap.Builder<String,ManagedProperty<?>> managedPropertiesBuilder=ImmutableSortedMap.naturalOrder();
  for (  Map.Entry<String,Multimap<PropertyAccessorType,StructMethodBinding>> propertyEntry : propertyBindings.entrySet()) {
    String propertyName=propertyEntry.getKey();
    Multimap<PropertyAccessorType,StructMethodBinding> accessorBindings=propertyEntry.getValue();
    if (isManagedProperty(propertyName,accessorBindings)) {
      boolean foundGetter=accessorBindings.containsKey(GET_GETTER) || accessorBindings.containsKey(IS_GETTER);
      boolean foundSetter=accessorBindings.containsKey(SETTER);
      if (foundSetter && !foundGetter) {
        throw new IllegalArgumentException(String.format("Managed property '%s' must both have an abstract getter as well as a setter.",propertyName));
      }
      ModelType<?> propertyType=determinePropertyType(propertyName,accessorBindings);
      boolean writable=accessorBindings.containsKey(SETTER);
      boolean declaredAsUnmanaged=isDeclaredAsHavingUnmanagedType(accessorBindings.get(GET_GETTER)) || isDeclaredAsHavingUnmanagedType(accessorBindings.get(IS_GETTER));
      boolean internal=!publicSchema.hasProperty(propertyName);
      managedPropertiesBuilder.put(propertyName,createProperty(propertyName,propertyType,writable,declaredAsUnmanaged,internal));
    }
  }
  return managedPropertiesBuilder.build();
}
