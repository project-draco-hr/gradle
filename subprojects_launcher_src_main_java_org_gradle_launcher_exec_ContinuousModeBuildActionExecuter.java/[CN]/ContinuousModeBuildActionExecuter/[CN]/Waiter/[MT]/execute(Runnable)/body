{
  FileSystemSubset taskFileSystemInputs=services.get(TaskFileSystemInputsAccumulator.class).get();
  FileWatcherFactory fileWatcherFactory=services.get(FileWatcherFactory.class);
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  FileWatcher watcher=fileWatcherFactory.watch(taskFileSystemInputs,new Action<Throwable>(){
    @Override public void execute(    Throwable throwable){
      error.set(throwable);
      latch.countDown();
    }
  }
,new FileWatcherListener(){
    @Override public void onChange(    FileWatcher watcher,    FileWatcherEvent event){
      watcher.stop();
      latch.countDown();
    }
  }
);
  try {
    runnable.run();
  }
 catch (  Exception e) {
    watcher.stop();
    throw UncheckedException.throwAsUncheckedException(e);
  }
  ListenableFuture<Boolean> keyboardHandlerFuture=submitAsyncKeyboardHandler(latch);
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    throw UncheckedException.throwAsUncheckedException(e);
  }
 finally {
    if (!keyboardHandlerFuture.isDone()) {
      keyboardHandlerFuture.cancel(true);
    }
 else     if (Futures.getUnchecked(keyboardHandlerFuture)) {
      cancellationRequested.set(true);
    }
  }
  Throwable throwable=error.get();
  if (throwable != null) {
    throw UncheckedException.throwAsUncheckedException(throwable);
  }
}
