{
  if ("<clinit>".equals(name)) {
    return null;
  }
  if (isPublicAPI(access) || ("<init>".equals(name) && isInnerClass)) {
    Set<String> invalidReferencedTypes=invalidReferencedTypes(signature == null ? desc : signature);
    if (invalidReferencedTypes.isEmpty()) {
      MethodVisitor mv=createAnnotationVisitor(access,name,desc,signature,exceptions,true);
      if ((access & ACC_ABSTRACT) != ACC_ABSTRACT) {
        mv.visitCode();
        mv.visitMethodInsn(INVOKESTATIC,internalClassName,UOE_METHOD,"()Ljava/lang/UnsupportedOperationException;",false);
        mv.visitInsn(ATHROW);
        mv.visitMaxs(1,0);
        mv.visitEnd();
        return createAnnotationVisitor(access,name,desc,signature,exceptions,false);
      }
      return mv;
    }
 else {
      String methodDesc=prettifyMethodDescriptor(access,name,desc);
      if (invalidReferencedTypes.size() == 1) {
        throw new InvalidPublicAPIException(String.format("In %s, type %s is exposed in the public API but its package is not one of the allowed packages.",methodDesc,invalidReferencedTypes.iterator().next()));
      }
 else {
        StringBuilder sb=new StringBuilder("The following types are referenced in ");
        sb.append(methodDesc);
        sb.append(" but their package is not one of the allowed packages:\n");
        for (        String invalidReferencedType : invalidReferencedTypes) {
          sb.append("   - ").append(invalidReferencedType).append("\n");
        }
        throw new InvalidPublicAPIException(sb.toString());
      }
    }
  }
  return null;
}
