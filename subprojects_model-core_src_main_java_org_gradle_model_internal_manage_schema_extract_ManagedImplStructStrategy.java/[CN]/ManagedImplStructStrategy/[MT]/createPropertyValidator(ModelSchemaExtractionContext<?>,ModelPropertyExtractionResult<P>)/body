{
  return new Action<ModelSchema<P>>(){
    @Override public void execute(    ModelSchema<P> propertySchema){
      ModelProperty<P> property=propertyResult.getProperty();
      if (!property.getStateManagementType().equals(ModelProperty.StateManagementType.MANAGED)) {
        return;
      }
      if (property.getName().equals("name") && Named.class.isAssignableFrom(parentContext.getType().getRawClass())) {
        return;
      }
      boolean isAllowedPropertyTypeOfManagedType=propertySchema instanceof ManagedImplModelSchema || propertySchema instanceof ModelValueSchema;
      boolean isDeclaredAsHavingUnmanagedType=propertyResult.getGetter().isAnnotationPresent(Unmanaged.class);
      if (isAllowedPropertyTypeOfManagedType && isDeclaredAsHavingUnmanagedType) {
        throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' is marked as @Unmanaged, but is of @Managed type '%s'. Please remove the @Managed annotation.%n",property.getName(),property.getType()));
      }
      if (!property.isWritable()) {
        if (isDeclaredAsHavingUnmanagedType) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("unmanaged property '%s' cannot be read only, unmanaged properties must have setters",property.getName()));
        }
      }
      if (propertySchema instanceof ModelCollectionSchema) {
        if (!(propertySchema instanceof ScalarCollectionSchema) && property.isWritable()) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot have a setter (%s properties must be read only).",property.getName(),property.getType().toString()));
        }
      }
    }
  }
;
}
