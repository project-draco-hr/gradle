{
  PropertyAccessorExtractionContext mergedGetter=property.mergeGetters();
  PropertyAccessorExtractionContext setter=property.getAccessor(SETTER);
  if (setter != null) {
    Method mostSpecificSetter=setter.getMostSpecificDeclaration();
    if (mergedGetter == null) {
      throw invalidMethods(context,"only paired getter/setter methods are supported",setter.getDeclaringMethods());
    }
    if (setter.isDeclaredAsAbstract()) {
      if (!mergedGetter.isDeclaredAsAbstract()) {
        throw invalidMethod(context,"setters are not allowed for non-abstract getters",mostSpecificSetter);
      }
    }
    if (mostSpecificSetter.getName().equals("setName") && Named.class.isAssignableFrom(context.getType().getRawClass())) {
      throw new InvalidManagedModelElementTypeException(context,String.format("@Managed types implementing %s must not declare a setter for the name property",Named.class.getName()));
    }
    if (mergedGetter.isDeclaredInManagedType() && !setter.isDeclaredInManagedType()) {
      throw invalidMethods(context,"unmanaged setter for managed getter",mergedGetter.getDeclaringMethods());
    }
    if (!mergedGetter.isDeclaredInManagedType() && setter.isDeclaredInManagedType()) {
      throw invalidMethods(context,"managed setter for unmanaged getter",mergedGetter.getDeclaringMethods());
    }
    if (!setter.isDeclaredInManagedType()) {
      return;
    }
    if (!Modifier.isAbstract(mostSpecificSetter.getModifiers())) {
      throw invalidMethod(context,"non-abstract setters are not allowed",mostSpecificSetter);
    }
    ModelType<?> propertyType=ModelType.returnType(mergedGetter.getMostSpecificDeclaration());
    ModelType<?> setterType=ModelType.paramType(mostSpecificSetter,0);
    if (!propertyType.equals(setterType)) {
      String message="setter method param must be of exactly the same type as the getter returns (expected: " + propertyType + ", found: "+ setterType+ ")";
      throw invalidMethod(context,message,mostSpecificSetter);
    }
  }
}
