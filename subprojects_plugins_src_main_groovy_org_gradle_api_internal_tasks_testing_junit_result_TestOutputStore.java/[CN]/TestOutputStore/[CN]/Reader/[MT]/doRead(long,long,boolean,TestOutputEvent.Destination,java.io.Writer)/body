{
  Index targetIndex=index.children.get(classId);
  if (targetIndex != null && testId != 0) {
    targetIndex=targetIndex.children.get(testId);
  }
  if (targetIndex == null) {
    return;
  }
  boolean stdout=destination == TestOutputEvent.Destination.StdOut;
  Region region=stdout ? targetIndex.stdOut : targetIndex.stdErr;
  if (region.start < 0) {
    return;
  }
  boolean ignoreClassLevel=!allClassOutput && testId != 0;
  boolean ignoreTestLevel=!allClassOutput && testId == 0;
  try {
    dataFile.seek(region.start);
    while (dataFile.getFilePointer() <= region.stop) {
      dataFile.read(recordHeaderBuffer);
      Input input=new Input(recordHeaderBuffer);
      boolean readStdout=input.readBoolean();
      long readClassId=input.readLong();
      long readTestId=input.readLong();
      int readLength=input.readInt();
      input.close();
      boolean isClassLevel=readTestId == 0;
      if (stdout != readStdout || classId != readClassId) {
        dataFile.skipBytes(readLength);
        continue;
      }
      if (ignoreClassLevel && isClassLevel) {
        dataFile.skipBytes(readLength);
        continue;
      }
      if (ignoreTestLevel && !isClassLevel) {
        dataFile.skipBytes(readLength);
        continue;
      }
      if (testId == 0 || testId == readTestId) {
        byte[] stringBytes=new byte[readLength];
        dataFile.read(stringBytes);
        String message;
        try {
          message=new String(stringBytes,messageStorageCharset.name());
        }
 catch (        UnsupportedEncodingException e) {
          throw UncheckedException.throwAsUncheckedException(e);
        }
        writer.write(message);
      }
 else {
        dataFile.skipBytes(readLength);
        continue;
      }
    }
  }
 catch (  IOException e1) {
    throw new UncheckedIOException(e1);
  }
}
