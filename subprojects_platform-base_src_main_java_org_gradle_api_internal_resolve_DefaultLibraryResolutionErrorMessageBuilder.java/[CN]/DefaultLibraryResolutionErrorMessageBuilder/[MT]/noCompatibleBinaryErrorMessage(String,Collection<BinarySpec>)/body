{
  HashMultimap<String,String> variants=HashMultimap.create();
  for (  BinarySpec spec : allBinaries) {
    VariantsMetaData md=DefaultVariantsMetaData.extractFrom(spec,schemaStore);
    Set<String> incompatibleDimensionTypes=VariantsMetaDataHelper.incompatibleDimensionTypes(variantsMetaData,md,resolveDimensions);
    for (    String dimension : resolveDimensions) {
      String value=md.getValueAsString(dimension);
      if (value != null) {
        String message=String.format("'%s'",value);
        if (incompatibleDimensionTypes.contains(dimension)) {
          message=String.format("%s but with an incompatible type (expected '%s' was '%s')",message,variantsMetaData.getDimensionType(dimension).getConcreteClass().getName(),md.getDimensionType(dimension).getConcreteClass().getName());
        }
        variants.put(dimension,message);
      }
    }
  }
  Joiner joiner=Joiner.on(", ").skipNulls();
  StringBuilder error=new StringBuilder(String.format("Cannot find a compatible variant for library '%s'.\n",libraryName));
  for (  String dimension : resolveDimensions) {
    String dimensionName=isPlatformDimension(dimension) ? "platform" : dimension;
    error.append("    Required ").append(dimensionName).append(" '").append(variantsMetaData.getValueAsString(dimension)).append("'");
    Set<String> available=new TreeSet<String>(variants.get(dimension));
    if (!available.isEmpty()) {
      error.append(", available: ").append(joiner.join(available)).append("\n");
    }
 else {
      error.append(" but no compatible variant was found\n");
    }
  }
  return error.toString();
}
