{
  Clock clock=new Clock();
  StaleClasses staleClasses=staleClassesDetecter.detectStaleClasses(inputs);
  if (staleClasses.isFullRebuildNeeded()) {
    LOG.lifecycle("Stale classes detection completed in {}. Full rebuild is needed due to: {}.",clock.getTime(),staleClasses.getFullRebuildReason());
    return cleaningCompiler.execute(spec);
  }
  if (staleClasses.getClassNames().isEmpty()) {
    return new WorkResult(){
      public boolean getDidWork(){
        return true;
      }
    }
;
  }
  PatternSet classesToDelete=new PatternSet();
  PatternSet sourceToCompile=new PatternSet();
  for (  String staleClass : staleClasses.getClassNames()) {
    String path=staleClass.replaceAll("\\.","/");
    classesToDelete.include(path.concat(".class"));
    sourceToCompile.include(path.concat(".java"));
  }
  spec.setSource(spec.getSource().getAsFileTree().matching(sourceToCompile));
  spec.setClasspath(Iterables.concat(spec.getClasspath(),asList(spec.getDestinationDir())));
  Set<File> staleClassFiles=fileOperations.fileTree(spec.getDestinationDir()).matching(classesToDelete).getFiles();
  for (  File staleClassFile : staleClassFiles) {
    staleClassFile.delete();
  }
  try {
    return cleaningCompiler.getCompiler().execute(spec);
  }
  finally {
    LOG.lifecycle("Stale classes detection completed in {}. Stale classes: {}, Compile include patterns: {}, Files to delete: {}",clock.getTime(),classesToDelete.getIncludes().size(),sourceToCompile.getIncludes(),staleClassFiles.size());
  }
}
