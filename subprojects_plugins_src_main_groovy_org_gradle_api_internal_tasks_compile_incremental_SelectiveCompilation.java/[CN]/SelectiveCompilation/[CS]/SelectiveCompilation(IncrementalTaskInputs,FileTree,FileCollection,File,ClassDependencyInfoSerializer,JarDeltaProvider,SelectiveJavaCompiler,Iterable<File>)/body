{
  this.jarDeltaProvider=jarDeltaProvider;
  this.compiler=compiler;
  Clock clock=new Clock();
  final InputOutputMapper mapper=new InputOutputMapper(sourceDirs,compileDestination);
  final ClassDependencyInfo dependencyInfo=dependencyInfoSerializer.readInfo();
  final PatternSet changedSourceOnly=new PatternSet();
  inputs.outOfDate(new Action<InputFileDetails>(){
    public void execute(    InputFileDetails inputFileDetails){
      if (rebuildNeeded != null) {
        return;
      }
      File inputFile=inputFileDetails.getFile();
      String name=inputFile.getName();
      if (name.endsWith(".java")) {
        JavaSourceClass source=mapper.toJavaSourceClass(inputFile);
        compiler.addStaleClass(source);
        changedSourceOnly.include(source.getRelativePath());
        Set<String> actualDependents=dependencyInfo.getActualDependents(source.getClassName());
        if (actualDependents == null) {
          rebuildNeeded="change to " + source.getClassName() + " requires full rebuild";
          return;
        }
        for (        String d : actualDependents) {
          JavaSourceClass dSource=mapper.toJavaSourceClass(d);
          compiler.addStaleClass(dSource);
          changedSourceOnly.include(dSource.getRelativePath());
        }
      }
      if (name.endsWith(".jar")) {
        JarDelta delta=jarDeltaProvider.getDelta(inputFile);
        if (delta.isFullRebuildNeeded()) {
          rebuildNeeded="change to " + inputFile + " requires full rebuild";
          return;
        }
        Iterable<String> classes=delta.getChangedClasses();
        for (        String c : classes) {
          Set<String> actualDependents=dependencyInfo.getActualDependents(c);
          for (          String d : actualDependents) {
            JavaSourceClass dSource=mapper.toJavaSourceClass(d);
            compiler.addStaleClass(dSource);
            changedSourceOnly.include(dSource.getRelativePath());
          }
        }
      }
    }
  }
);
  if (rebuildNeeded != null) {
    LOG.lifecycle("Stale classes detection completed in {}. Rebuild needed: {}.",clock.getTime(),rebuildNeeded);
    this.classpath=compileClasspath;
    this.source=source;
    return;
  }
  inputs.removed(new Action<InputFileDetails>(){
    public void execute(    InputFileDetails inputFileDetails){
      compiler.addStaleClass(mapper.toJavaSourceClass(inputFileDetails.getFile()));
    }
  }
);
  if (changedSourceOnly.getIncludes().isEmpty()) {
    this.compilationNeeded=false;
    this.classpath=compileClasspath;
    this.source=source;
  }
 else {
    this.classpath=compileClasspath.plus(new SimpleFileCollection(compileDestination));
    this.source=source.matching(changedSourceOnly);
  }
  LOG.lifecycle("Stale classes detection completed in {}. Stale classes: {}, Compile include patterns: {}, Files to delete: {}",clock.getTime(),compiler.getStaleClasses().size(),changedSourceOnly.getIncludes(),compiler.getStaleClasses());
}
