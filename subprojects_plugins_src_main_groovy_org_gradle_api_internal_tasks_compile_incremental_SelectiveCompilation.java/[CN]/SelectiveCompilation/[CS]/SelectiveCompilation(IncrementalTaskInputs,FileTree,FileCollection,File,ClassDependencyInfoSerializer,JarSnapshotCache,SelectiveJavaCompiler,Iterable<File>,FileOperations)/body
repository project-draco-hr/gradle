{
  this.operations=operations;
  this.jarSnapshotFeeder=new JarSnapshotFeeder(jarSnapshotCache,new JarSnapshotter(new DefaultHasher()));
  this.compiler=compiler;
  Clock clock=new Clock();
  final InputOutputMapper mapper=new InputOutputMapper(sourceDirs,compileDestination);
  final ClassDependencyInfo dependencyInfo=dependencyInfoSerializer.readInfo();
  final PatternSet changedSourceOnly=new PatternSet();
  InputFileDetailsAction action=new InputFileDetailsAction(mapper,compiler,changedSourceOnly,dependencyInfo);
  inputs.outOfDate(action);
  inputs.removed(action);
  if (fullRebuildNeeded != null) {
    LOG.lifecycle("Stale classes detection completed in {}. Rebuild needed: {}.",clock.getTime(),fullRebuildNeeded);
    this.classpath=compileClasspath;
    this.source=source;
    return;
  }
  compiler.deleteStaleClasses();
  Set<File> filesToCompile=source.matching(changedSourceOnly).getFiles();
  if (filesToCompile.isEmpty()) {
    this.compilationNeeded=false;
    this.classpath=compileClasspath;
    this.source=source;
  }
 else {
    this.classpath=compileClasspath.plus(new SimpleFileCollection(compileDestination));
    this.source=source.matching(changedSourceOnly);
  }
  LOG.lifecycle("Stale classes detection completed in {}. Compile include patterns: {}.",clock.getTime(),changedSourceOnly.getIncludes());
}
