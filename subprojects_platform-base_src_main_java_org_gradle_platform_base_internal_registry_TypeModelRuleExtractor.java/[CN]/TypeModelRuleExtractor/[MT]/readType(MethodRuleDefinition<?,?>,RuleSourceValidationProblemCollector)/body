{
  validateIsVoidMethod(ruleDefinition,problems);
  if (ruleDefinition.getReferences().size() != 1) {
    problems.add(ruleDefinition,String.format("A method %s must have a single parameter of type %s.",getDescription(),TypeBuilder.class.getName()));
    return null;
  }
  ModelReference<?> subjectReference=ruleDefinition.getSubjectReference();
  ModelType<?> builder=subjectReference.getType();
  Class<?> rawBuilderType=builder.getRawClass();
  if (!rawBuilderType.isAssignableFrom(builderInterface.getRawClass()) || !TypeBuilder.class.isAssignableFrom(rawBuilderType)) {
    problems.add(ruleDefinition,String.format("A method %s must have a single parameter of type %s.",getDescription(),TypeBuilder.class.getName()));
    return null;
  }
  if (builder.getTypeVariables().size() != 1) {
    problems.add(ruleDefinition,String.format("Parameter of type %s must declare a type parameter.",rawBuilderType.getName()));
    return null;
  }
  ModelType<?> subType=builder.getTypeVariables().get(0);
  if (subType.isWildcard()) {
    problems.add(ruleDefinition,String.format("%s type '%s' cannot be a wildcard type (i.e. cannot use ? super, ? extends etc.).",StringUtils.capitalize(modelName),subType.toString()));
    return null;
  }
  if (!baseInterface.isAssignableFrom(subType)) {
    problems.add(ruleDefinition,String.format("%s type '%s' is not a subtype of '%s'.",StringUtils.capitalize(modelName),subType.toString(),baseInterface.toString()));
    return null;
  }
  return subType.asSubtype(baseInterface);
}
