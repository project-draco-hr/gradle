{
  return new ToolChain(){
    public <T extends BinaryCompileSpec>Compiler<T> createCompiler(    Class<T> specType){
      if (CppCompileSpec.class.isAssignableFrom(specType)) {
        return (Compiler<T>)new GppCompiler(gppExecutable,execActionFactory,canUseCommandFile(version));
      }
      throw new IllegalArgumentException(String.format("No suitable compiler available for %s.",specType));
    }
    public <T extends LinkerSpec>Compiler<T> createLinker(    Class<T> specType){
      if (ExecutableLinkerSpec.class.isAssignableFrom(specType) || SharedLibraryLinkerSpec.class.isAssignableFrom(specType)) {
        return (Compiler<T>)new GppLinker(gppExecutable,execActionFactory,canUseCommandFile(version));
      }
      if (StaticLibraryLinkerSpec.class.isAssignableFrom(specType)) {
        return (Compiler<T>)new ArStaticLibraryLinker(arExecutable,execActionFactory);
      }
      throw new IllegalArgumentException(String.format("No suitable linker available for %s.",specType));
    }
  }
;
}
