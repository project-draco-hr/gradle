{
  lifecycleLock.lock();
  try {
    if (stateCoordinator != null) {
      throw new IllegalStateException("cannot start daemon as it is already running");
    }
    connectorAddress=connector.start(new IncomingConnectionHandler(){
      public void handle(      final Connection<Object> connection){
        handlersExecutor.execute(new Runnable(){
          public void run(){
            try {
              handleIncoming(connection);
            }
 catch (            RuntimeException e) {
              LOGGER.error("Error processing the incoming command.",e);
              throw e;
            }
          }
        }
);
      }
    }
);
    registryUpdater=new DomainRegistryUpdater(daemonRegistry,connectorAddress);
    Runnable startHandler=new Runnable(){
      public void run(){
        LOGGER.lifecycle("Daemon starting at: " + new Date() + ", with address: "+ connectorAddress);
        registryUpdater.onStart();
      }
    }
;
    Runnable startActivityHandler=new Runnable(){
      public void run(){
        registryUpdater.onStartActivity();
      }
    }
;
    Runnable completeActivityHandler=new Runnable(){
      public void run(){
        registryUpdater.onCompleteActivity();
      }
    }
;
    Runnable stopHandler=new Runnable(){
      public void run(){
        LOGGER.info("Stop requested. Daemon is stopping accepting new connections...");
        registryUpdater.onStop();
        connector.stop();
      }
    }
;
    stateCoordinator=new DaemonStateCoordinator(startHandler,startActivityHandler,completeActivityHandler,stopHandler);
    stateCoordinator.start();
  }
  finally {
    lifecycleLock.unlock();
  }
}
