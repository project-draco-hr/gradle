{
  LOGGER.info("start() called on daemon - {}",daemonContext);
  lifecyleLock.lock();
  try {
    if (stateCoordinator != null) {
      throw new IllegalStateException("cannot start daemon as it is already running");
    }
    connectorAddress=connector.start(new IncomingConnectionHandler(){
      public void handle(      final Connection<Object> connection){
        handlersExecutor.execute(new Runnable(){
          private Command command;
          public void run(){
            try {
              command=(Command)connection.receive();
              LOGGER.info("Daemon (pid: {}) received command: {}",daemonContext.getPid(),command);
            }
 catch (            RuntimeException e) {
              String message=String.format("Unable to receive command from connection: '%s'",connection);
              LOGGER.warn(message + ". Dispatching the failure to the daemon client...",e);
              connection.dispatch(new DaemonFailure(new RuntimeException(message,e)));
              return;
            }
            try {
              LOGGER.debug(DaemonMessages.STARTED_EXECUTING_COMMAND + command + " with connection: "+ connection+ ".");
              commandExecuter.executeCommand(connection,command,daemonContext,stateCoordinator);
            }
 catch (            RuntimeException e) {
              String message=String.format("Uncaught exception when executing command: '%s' from connection: '%s'.",command,connection);
              LOGGER.warn(message + ". Dispatching the failure to the daemon client...",e);
              connection.dispatch(new DaemonFailure(new RuntimeException(message,e)));
            }
 finally {
              LOGGER.debug(DaemonMessages.FINISHED_EXECUTING_COMMAND + command);
            }
          }
        }
);
      }
    }
);
    registryUpdater=new DomainRegistryUpdater(daemonRegistry,daemonContext,password,connectorAddress);
    Runnable onStart=new Runnable(){
      public void run(){
        LOGGER.debug("Daemon starting at: " + new Date() + ", with address: "+ connectorAddress);
        registryUpdater.onStart();
      }
    }
;
    Runnable onStartCommand=new Runnable(){
      public void run(){
        registryUpdater.onStartActivity();
      }
    }
;
    Runnable onFinishCommand=new Runnable(){
      public void run(){
        registryUpdater.onCompleteActivity();
      }
    }
;
    Runnable onStop=new Runnable(){
      public void run(){
        LOGGER.info("Stop requested. Daemon is stopping accepting new connections...");
        registryUpdater.onStop();
        connector.stop();
      }
    }
;
    stateCoordinator=new DaemonStateCoordinator(onStart,onStartCommand,onFinishCommand,onStop);
    stateCoordinator.start();
  }
  finally {
    lifecyleLock.unlock();
  }
}
