{
  LOGGER.info("start() called on daemon - {}",daemonContext);
  lifecyleLock.lock();
  try {
    if (stateCoordinator != null) {
      throw new IllegalStateException("cannot start daemon as it is already running");
    }
    connectorAddress=connector.start(new IncomingConnectionHandler(){
      public void handle(      final Connection<Object> connection){
        handlersExecutor.execute(new Runnable(){
          private Command command;
          public void run(){
            try {
              command=(Command)connection.receive();
              LOGGER.debug("received command {} in new thread",command);
              commandExecuter.executeCommand(connection,command,daemonContext,stateCoordinator);
            }
 catch (            RuntimeException e) {
              LOGGER.error("Error processing the incoming command.",e);
              throw e;
            }
 finally {
              LOGGER.debug("finishing processing of command {}",command);
            }
          }
        }
);
      }
    }
);
    registryUpdater=new DomainRegistryUpdater(daemonRegistry,daemonContext,password,connectorAddress);
    Runnable onStart=new Runnable(){
      public void run(){
        LOGGER.debug("Daemon starting at: " + new Date() + ", with address: "+ connectorAddress);
        registryUpdater.onStart();
      }
    }
;
    Runnable onStartCommand=new Runnable(){
      public void run(){
        registryUpdater.onStartActivity();
      }
    }
;
    Runnable onFinishCommand=new Runnable(){
      public void run(){
        registryUpdater.onCompleteActivity();
      }
    }
;
    Runnable onStop=new Runnable(){
      public void run(){
        LOGGER.info("Stop requested. Daemon is stopping accepting new connections...");
        registryUpdater.onStop();
        connector.stop();
      }
    }
;
    stateCoordinator=new DaemonStateCoordinator(onStart,onStartCommand,onFinishCommand,onStop);
    stateCoordinator.start();
  }
  finally {
    lifecyleLock.unlock();
  }
}
