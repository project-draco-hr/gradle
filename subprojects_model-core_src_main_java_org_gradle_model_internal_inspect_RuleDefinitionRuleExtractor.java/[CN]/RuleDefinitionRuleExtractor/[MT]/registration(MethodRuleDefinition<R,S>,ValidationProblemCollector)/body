{
  validateIsVoidMethod(ruleDefinition,problems);
  if (ruleDefinition.getReferences().size() < 2) {
    problems.add(ruleDefinition,"A method " + getDescription() + " must have at least two parameters");
    return null;
  }
  ModelType<?> ruleType=ruleDefinition.getReferences().get(0).getType();
  if (!RULE_SOURCE_MODEL_TYPE.isAssignableFrom(ruleType)) {
    problems.add(ruleDefinition,"The first parameter of a method " + getDescription() + " must be a subtype of RuleSource");
  }
  if (problems.hasProblems()) {
    return null;
  }
  final ModelType<? extends RuleSource> ruleSourceType=ruleType.asSubtype(RULE_SOURCE_MODEL_TYPE);
  return new ExtractedModelRule(){
    @Override public void apply(    ModelRegistry modelRegistry,    ModelPath scope){
      final ModelReference<?> targetReference=ruleDefinition.getReferences().get(1);
      List<ModelReference<?>> inputs=ruleDefinition.getReferences().subList(2,ruleDefinition.getReferences().size());
      modelRegistry.configure(ModelActionRole.Defaults,DirectNodeInputUsingModelAction.of(targetReference,ruleDefinition.getDescriptor(),inputs,new BiAction<MutableModelNode,List<ModelView<?>>>(){
        @Override public void execute(        MutableModelNode subjectNode,        List<ModelView<?>> modelViews){
          Object[] parameters=new Object[2 + modelViews.size()];
          parameters[0]=DirectInstantiator.INSTANCE.newInstance(ruleSourceType.getConcreteClass());
          parameters[1]=subjectNode.asImmutable(targetReference.getType(),ruleDefinition.getDescriptor()).getInstance();
          for (int i=2; i < parameters.length; i++) {
            parameters[i]=modelViews.get(i).getInstance();
          }
          ruleDefinition.getRuleInvoker().invoke(parameters);
          subjectNode.applyToSelf(ruleSourceType.getConcreteClass());
        }
      }
));
    }
    @Override public List<? extends Class<?>> getRuleDependencies(){
      return Collections.emptyList();
    }
  }
;
}
