{
  if (cancellationToken.isCancellationRequested()) {
    return;
  }
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  final StoppableExecutor executorService=executorFactory.create("continuous build - wait");
  final Lock lock=new ReentrantLock();
  final Condition condition=lock.newCondition();
  final AtomicLong lastChangeAt=new AtomicLong(0);
  Runnable cancellationHandler=new Runnable(){
    @Override public void run(){
      signal(lock,condition);
    }
  }
;
  FileWatcher watcher=fileWatcherFactory.watch(taskFileSystemInputs,new Action<Throwable>(){
    @Override public void execute(    Throwable throwable){
      error.set(throwable);
      signal(lock,condition);
    }
  }
,new FileWatcherListener(){
    @Override public void onChange(    final FileWatcher watcher,    FileWatcherEvent event){
      if (!(event.getType() == FileWatcherEvent.Type.MODIFY && event.getFile().isDirectory())) {
        signal(lock,condition,new Runnable(){
          @Override public void run(){
            lastChangeAt.set(System.currentTimeMillis());
          }
        }
);
      }
    }
  }
);
  try {
    cancellationToken.addCallback(cancellationHandler);
    notifier.run();
    lock.lock();
    try {
      long lastChangeAtValue=lastChangeAt.get();
      while (!cancellationToken.isCancellationRequested() && error.get() == null && (lastChangeAtValue == 0 || System.currentTimeMillis() - lastChangeAtValue < quietPeriodMillis)) {
        condition.await(quietPeriodMillis,TimeUnit.MILLISECONDS);
        lastChangeAtValue=lastChangeAt.get();
      }
    }
  finally {
      lock.unlock();
    }
    Throwable throwable=error.get();
    if (throwable != null) {
      throw throwable;
    }
  }
 catch (  Throwable e) {
    throw UncheckedException.throwAsUncheckedException(e);
  }
 finally {
    cancellationToken.removeCallback(cancellationHandler);
    CompositeStoppable.stoppable(watcher,executorService).stop();
  }
}
