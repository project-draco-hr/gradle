{
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  final StoppableExecutor executorService=executorFactory.create("continuous building - wait");
  FileWatcher watcher=fileWatcherFactory.watch(taskFileSystemInputs,new Action<Throwable>(){
    @Override public void execute(    Throwable throwable){
      error.set(throwable);
      latch.countDown();
    }
  }
,new FileWatcherListener(){
    private IdleTimeout timeout;
    @Override public void onChange(    final FileWatcher watcher,    FileWatcherEvent event){
      if (timeout == null) {
        timeout=new IdleTimeout(QUIET_PERIOD,new Runnable(){
          @Override public void run(){
            watcher.stop();
            latch.countDown();
          }
        }
);
        executorService.execute(new Runnable(){
          @Override public void run(){
            timeout.await();
          }
        }
);
      }
      timeout.tick();
    }
  }
);
  executorService.submit(new Runnable(){
    @Override public void run(){
      try {
        final InputStream inputStream=systemInProxy;
        while (!Thread.currentThread().isInterrupted()) {
          int c=inputStream.read();
          if (c == KEY_CODE_CTRL_D || c == EOF) {
            cancellationToken.doCancel();
            break;
          }
        }
      }
 catch (      IOException e) {
        throw UncheckedException.throwAsUncheckedException(e);
      }
    }
  }
);
  executorService.submit(new Runnable(){
    @Override public void run(){
      while (!cancellationToken.isCancellationRequested()) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          return;
        }
      }
      latch.countDown();
    }
  }
);
  try {
    notifier.run();
    latch.await();
    Throwable throwable=error.get();
    if (throwable != null) {
      throw UncheckedException.throwAsUncheckedException(throwable);
    }
  }
 catch (  Exception e) {
    throw UncheckedException.throwAsUncheckedException(e);
  }
 finally {
    CompositeStoppable.stoppable(watcher,new Stoppable(){
      @Override public void stop(){
        executorService.shutdownNow();
      }
    }
).stop();
  }
}
