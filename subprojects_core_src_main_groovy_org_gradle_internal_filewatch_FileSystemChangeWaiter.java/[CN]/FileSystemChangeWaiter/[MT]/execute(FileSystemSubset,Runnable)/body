{
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
  final StoppableExecutor executorService=executorFactory.create("quiet period waiter");
  FileWatcher watcher=fileWatcherFactory.watch(taskFileSystemInputs,new Action<Throwable>(){
    @Override public void execute(    Throwable throwable){
      error.set(throwable);
      latch.countDown();
    }
  }
,new FileWatcherListener(){
    private IdleTimeout timeout;
    @Override public void onChange(    final FileWatcher watcher,    FileWatcherEvent event){
      if (timeout == null) {
        timeout=new IdleTimeout(QUIET_PERIOD,new Runnable(){
          @Override public void run(){
            watcher.stop();
            latch.countDown();
          }
        }
);
        executorService.execute(new Runnable(){
          @Override public void run(){
            timeout.await();
          }
        }
);
      }
      timeout.tick();
    }
  }
);
  final StoppableExecutor keyboardHandlerExecutor=executorFactory.create("Continuous building keyboard handler");
  ListenableFuture<Boolean> keyboardHandlerFuture=submitAsyncKeyboardHandler(MoreExecutors.listeningDecorator(keyboardHandlerExecutor),latch);
  try {
    notifier.run();
    latch.await();
    Throwable throwable=error.get();
    if (throwable != null) {
      throw UncheckedException.throwAsUncheckedException(throwable);
    }
  }
 catch (  Exception e) {
    throw UncheckedException.throwAsUncheckedException(e);
  }
 finally {
    if (!keyboardHandlerFuture.isDone()) {
      keyboardHandlerFuture.cancel(true);
    }
 else     if (Futures.getUnchecked(keyboardHandlerFuture)) {
      cancellationRequested.set(true);
    }
    CompositeStoppable.stoppable(watcher,executorService,keyboardHandlerExecutor).stop();
  }
}
