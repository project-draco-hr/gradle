{
  final Clock clock=new Clock();
  final TaskOutputsInternal taskOutputs=task.getOutputs();
  boolean cacheAllowed=taskOutputs.isCacheAllowed();
  boolean shouldCache;
  try {
    shouldCache=cacheAllowed && taskOutputs.isCacheEnabled();
  }
 catch (  Exception t) {
    throw new GradleException(String.format("Could not evaluate TaskOutputs.cacheIf for %s.",task),t);
  }
  LOGGER.debug("Determining if {} is cached already",task);
  TaskCacheKey cacheKey=null;
  if (shouldCache) {
    TaskArtifactState taskState=context.getTaskArtifactState();
    try {
      cacheKey=taskState.calculateCacheKey();
      LOGGER.debug("Cache key for {} is {}",task,cacheKey);
    }
 catch (    Exception e) {
      throw new GradleException(String.format("Could not build cache key for %s.",task),e);
    }
  }
 else {
    if (!cacheAllowed) {
      LOGGER.debug("Not caching {} as it is not allowed",task);
    }
 else {
      LOGGER.debug("Not caching {} as task output is not cacheable.",task);
    }
  }
  if (cacheKey != null) {
    try {
      boolean found=getCache().load(cacheKey,new TaskOutputReader(){
        @Override public void readFrom(        InputStream input) throws IOException {
          packer.unpack(taskOutputs,input);
          LOGGER.info("Unpacked output for {} from cache (took {}).",task,clock.getTime());
        }
      }
);
      if (found) {
        state.upToDate("FROM-CACHE");
        return;
      }
    }
 catch (    Exception e) {
      LOGGER.warn("Could not load cached output for {} with cache key {}",task,cacheKey,e);
    }
  }
  delegate.execute(task,state,context);
  if (cacheKey != null && state.getFailure() == null) {
    try {
      getCache().store(cacheKey,new TaskOutputWriter(){
        @Override public void writeTo(        OutputStream output) throws IOException {
          packer.pack(taskOutputs,output);
        }
      }
);
    }
 catch (    Exception e) {
      LOGGER.warn("Could not cache results for {} for cache key {}",task,cacheKey,e);
    }
  }
}
