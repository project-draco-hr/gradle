{
  final Clock clock=new Clock();
  final TaskOutputsInternal taskOutputs=task.getOutputs();
  boolean cacheEnabled;
  try {
    cacheEnabled=taskOutputs.isCacheEnabled();
  }
 catch (  Exception t) {
    throw new GradleException(String.format("Could not evaluate TaskOutputs.cacheIf for %s.",task),t);
  }
  LOGGER.debug("Determining if {} is cached already",task);
  TaskCacheKey cacheKey=null;
  NotCachedReason reason=null;
  if (cacheEnabled) {
    if (taskOutputs.hasDeclaredOutputs()) {
      if (taskOutputs.isCacheAllowed()) {
        TaskArtifactState taskState=context.getTaskArtifactState();
        try {
          cacheKey=taskState.calculateCacheKey();
          LOGGER.info("Cache key for {} is {}",task,cacheKey);
        }
 catch (        Exception e) {
          throw new GradleException(String.format("Could not build cache key for %s.",task),e);
        }
        if (cacheKey != null) {
          try {
            boolean found=getCache().load(cacheKey,new TaskOutputReader(){
              @Override public void readFrom(              InputStream input) throws IOException {
                packer.unpack(taskOutputs,input);
                LOGGER.info("Unpacked output for {} from cache (took {}).",task,clock.getTime());
              }
            }
);
            if (found) {
              state.upToDate("FROM-CACHE");
              taskOutputCacheListener.fromCache(task);
              return;
            }
            reason=NotCachedReason.NOT_IN_CACHE;
          }
 catch (          Exception e) {
            LOGGER.warn("Could not load cached output for {} with cache key {}",task,cacheKey,e);
            reason=NotCachedReason.ERROR_LOADING_CACHE_ENTRY;
          }
        }
      }
 else {
        LOGGER.info("Not caching {} because it declares multiple output files for a single output property via `@OutputFiles`, `@OutputDirectories` or `TaskOutputs.files()`",task);
        reason=NotCachedReason.MULTIPLE_OUTPUTS;
      }
    }
 else {
      LOGGER.info("Not caching {} as task has declared no outputs",task);
      reason=NotCachedReason.NO_OUTPUTS;
    }
  }
 else {
    LOGGER.debug("Not caching {} as task output is not cacheable.",task);
    reason=NotCachedReason.NOT_CACHEABLE;
  }
  taskOutputCacheListener.notCached(task,reason);
  delegate.execute(task,state,context);
  if (cacheKey != null && state.getFailure() == null) {
    try {
      getCache().store(cacheKey,new TaskOutputWriter(){
        @Override public void writeTo(        OutputStream output) throws IOException {
          packer.pack(taskOutputs,output);
        }
      }
);
    }
 catch (    Exception e) {
      LOGGER.warn("Could not cache results for {} for cache key {}",task,cacheKey,e);
    }
  }
}
