{
  Clock clock=new Clock();
  TaskOutputsInternal taskOutputs=task.getOutputs();
  boolean cacheAllowed=taskOutputs.isCacheAllowed();
  boolean shouldCache;
  try {
    shouldCache=cacheAllowed && taskOutputs.isCacheEnabled();
  }
 catch (  Exception t) {
    throw new GradleException(String.format("Could not evaluate TaskOutputs.cacheIf for %s.",task),t);
  }
  LOGGER.debug("Determining if {} is cached already",task);
  TaskCacheKey cacheKey=null;
  if (shouldCache) {
    TaskArtifactState taskState=context.getTaskArtifactState();
    try {
      cacheKey=taskState.calculateCacheKey();
      LOGGER.debug("Cache key for {} is {}",task,cacheKey);
    }
 catch (    Exception e) {
      throw new GradleException(String.format("Could not build cache key for %s.",task),e);
    }
  }
 else {
    if (!cacheAllowed) {
      LOGGER.debug("Not caching {} as it is not allowed",task);
    }
 else {
      LOGGER.debug("Not caching {} as task output is not cacheable.",task);
    }
  }
  if (cacheKey != null) {
    try {
      TaskOutputReader cachedOutput=getCache().get(cacheKey);
      if (cachedOutput != null) {
        packer.unpack(taskOutputs,cachedOutput);
        LOGGER.info("Unpacked output for {} from cache (took {}).",task,clock.getTime());
        state.upToDate("FROM-CACHE");
        return;
      }
    }
 catch (    Exception e) {
      LOGGER.warn("Could not load cached output for {} with cache key {}",task,cacheKey,e);
    }
  }
  delegate.execute(task,state,context);
  if (cacheKey != null && state.getFailure() == null) {
    try {
      TaskOutputWriter cachedOutput=packer.createWriter(taskOutputs);
      getCache().put(cacheKey,cachedOutput);
    }
 catch (    Exception e) {
      LOGGER.warn("Could not cache results for {} for cache key {}",task,cacheKey,e);
    }
  }
}
