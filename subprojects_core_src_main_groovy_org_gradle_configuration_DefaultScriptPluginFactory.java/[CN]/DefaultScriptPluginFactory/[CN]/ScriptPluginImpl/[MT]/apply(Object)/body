{
  DefaultServiceRegistry services=new DefaultServiceRegistry();
  services.add(ScriptPluginFactory.class,DefaultScriptPluginFactory.this);
  services.add(ScriptHandlerFactory.class,scriptHandlerFactory);
  services.add(ClassLoaderScope.class,classLoaderScope.getBase());
  services.add(LoggingManagerInternal.class,loggingManagerFactory.create());
  services.add(Instantiator.class,instantiator);
  services.add(ScriptHandler.class,scriptHandler);
  services.add(FileLookup.class,fileLookup);
  ScriptSource withImports=importsReader.withImports(scriptSource);
  PluginDependenciesService pluginDependenciesService=new PluginDependenciesService(getSource());
  services.add(PluginDependenciesService.class,pluginDependenciesService);
  ScriptCompiler compiler=scriptCompilerFactory.createCompiler(withImports);
  compiler.setClassloader(classLoaderScope.getBase().getChildClassLoader());
  boolean supportsPluginsBlock=ProjectScript.class.isAssignableFrom(scriptType);
  String onPluginBlockError=supportsPluginsBlock ? null : "Only Project build scripts can contain plugins {} blocks";
  PluginsAndBuildscriptTransformer scriptBlockTransformer=new PluginsAndBuildscriptTransformer(classpathClosureName,onPluginBlockError);
  StatementExtractingScriptTransformer classpathScriptTransformer=new StatementExtractingScriptTransformer(classpathClosureName,scriptBlockTransformer);
  compiler.setTransformer(classpathScriptTransformer);
  ScriptRunner<? extends BasicScript> classPathScriptRunner=compiler.compile(scriptType);
  classPathScriptRunner.getScript().init(target,services);
  classPathScriptRunner.run();
  Configuration classpathConfiguration=scriptHandler.getConfigurations().getByName(ScriptHandler.CLASSPATH_CONFIGURATION);
  Set<File> files=classpathConfiguration.getFiles();
  ClassPath classPath=new DefaultClassPath(files);
  ClassLoader exportedClassLoader=classLoaderScope.export(classPath);
  List<PluginRequest> pluginRequests=pluginDependenciesService.getRequests();
  if (!pluginRequests.isEmpty()) {
    Map<String,List<PluginRequest>> groupedById=CollectionUtils.groupBy(pluginRequests,new Transformer<String,PluginRequest>(){
      public String transform(      PluginRequest pluginRequest){
        return pluginRequest.getId();
      }
    }
);
    groupedById.remove(NoopPluginResolver.PLUGIN_ID);
    for (    Map.Entry<String,List<PluginRequest>> entry : groupedById.entrySet()) {
      List<PluginRequest> pluginRequestsForId=entry.getValue();
      if (pluginRequestsForId.size() > 1) {
        PluginRequest first=pluginRequests.get(0);
        PluginRequest second=pluginRequests.get(1);
        InvalidPluginRequestException exception=new InvalidPluginRequestException(second,"Plugin with id '" + entry.getKey() + "' was already requested at line "+ first.getLineNumber());
        throw new LocationAwareException(exception,second.getScriptSource(),second.getLineNumber());
      }
    }
    PluginResolver pluginResolver=pluginResolverFactory.createPluginResolver(exportedClassLoader);
    @SuppressWarnings("ConstantConditions") PluginResolutionApplicator resolutionApplicator=new PluginResolutionApplicator((PluginAware)target,classLoaderScope);
    PluginRequestApplicator requestApplicator=new PluginRequestApplicator(pluginResolver,resolutionApplicator);
    requestApplicator.applyPlugin(pluginRequests);
  }
  classLoaderScope.lock();
  compiler.setClassloader(classLoaderScope.getScopeClassLoader());
  compiler.setTransformer(new BuildScriptTransformer("no_" + classpathScriptTransformer.getId(),classpathScriptTransformer.invert()));
  ScriptRunner<? extends BasicScript> runner=compiler.compile(scriptType);
  BasicScript script=runner.getScript();
  script.init(target,services);
  if (target instanceof ScriptAware) {
    ((ScriptAware)target).setScript(script);
  }
  runner.run();
}
