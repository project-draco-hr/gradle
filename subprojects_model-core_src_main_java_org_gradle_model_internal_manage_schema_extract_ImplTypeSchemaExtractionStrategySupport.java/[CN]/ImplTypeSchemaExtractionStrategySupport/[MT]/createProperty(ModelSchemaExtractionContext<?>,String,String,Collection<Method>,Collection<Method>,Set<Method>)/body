{
  Method mostSpecificGetter=getterMethods.iterator().next();
  boolean getterDeclaredInManagedType=isGetterDefinedInManagedType(extractionContext,methodName,getterMethods);
  if (mostSpecificGetter.getParameterTypes().length != 0) {
    invalidGetterHasParameterTypes(extractionContext,mostSpecificGetter);
    return null;
  }
  boolean abstractGetter=Modifier.isAbstract(mostSpecificGetter.getModifiers());
  if (!getterDeclaredInManagedType && mostSpecificGetter.getReturnType().isPrimitive()) {
    invalidGetterHasPrimitiveType(extractionContext,mostSpecificGetter);
    return null;
  }
  boolean managedProperty=getterDeclaredInManagedType && abstractGetter;
  ModelType<?> returnType=ModelType.returnType(mostSpecificGetter);
  boolean writable=!setterMethods.isEmpty();
  if (writable) {
    Method setter=setterMethods.iterator().next();
    boolean abstractSetter=Modifier.isAbstract(setter.getModifiers());
    if (!abstractGetter && abstractSetter) {
      throw invalidMethod(extractionContext,"setters are not allowed for non-abstract getters",setter);
    }
    boolean setterDeclaredInManagedType=isMethodDeclaredInManagedType(setterMethods);
    if (getterDeclaredInManagedType && !setterDeclaredInManagedType) {
      throw invalidMethods(extractionContext,"unmanaged setter for managed getter",Iterables.concat(getterMethods,setterMethods));
    }
 else     if (!getterDeclaredInManagedType && setterDeclaredInManagedType) {
      throw invalidMethods(extractionContext,"managed setter for unmanaged getter",Iterables.concat(getterMethods,setterMethods));
    }
    if (setterDeclaredInManagedType) {
      validateSetter(extractionContext,returnType,setter);
    }
    handledMethods.addAll(setterMethods);
  }
  handledMethods.addAll(getterMethods);
  Map<Class<? extends Annotation>,Annotation> annotations=Maps.newLinkedHashMap();
  for (  Method getterMethod : getterMethods) {
    for (    Annotation annotation : getterMethod.getDeclaredAnnotations()) {
      if (!annotations.containsKey(annotation.annotationType())) {
        annotations.put(annotation.annotationType(),annotation);
      }
    }
  }
  ImmutableSet<ModelType<?>> declaringClasses=ImmutableSet.copyOf(Iterables.transform(getterMethods,new Function<Method,ModelType<?>>(){
    public ModelType<?> apply(    Method input){
      return ModelType.of(input.getDeclaringClass());
    }
  }
));
  return ModelProperty.of(returnType,propertyName,managedProperty,writable,declaringClasses,annotations);
}
