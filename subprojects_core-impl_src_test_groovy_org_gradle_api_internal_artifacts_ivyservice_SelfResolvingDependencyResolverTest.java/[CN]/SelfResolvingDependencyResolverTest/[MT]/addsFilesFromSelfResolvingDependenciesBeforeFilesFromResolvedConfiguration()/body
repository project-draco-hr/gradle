{
  final AbstractDependency dependency=context.mock(AbstractDependency.class);
  context.checking(new Expectations(){
{
      one(delegate).resolve(configuration,ivy,moduleDescriptor);
      will(returnValue(resolvedConfiguration));
      allowing(configuration).getAllDependencies();
      will(returnValue(toDomainObjectSet(DependencyInternal.class,dependency)));
      allowing(configuration).isTransitive();
      will(returnValue(true));
    }
  }
);
  ResolvedConfiguration actualResolvedConfiguration=resolver.resolve(this.configuration,ivy,moduleDescriptor);
  assertThat(actualResolvedConfiguration,not(sameInstance(resolvedConfiguration)));
  final File configFile=new File("from config");
  final File depFile=new File("from dep");
  final FileCollection depFiles=context.mock(FileCollection.class);
  final boolean transitive=true;
  context.checking(new Expectations(){
{
      allowing(configuration);
      will(returnValue(transitive));
      one(resolvedConfiguration).getFiles(Specs.SATISFIES_ALL);
      will(returnValue(toSet(configFile)));
      one(dependency).resolve(with(notNullValue(DependencyResolveContext.class)));
      will(new Action(){
        public void describeTo(        Description description){
          description.appendText("add files to context");
        }
        public Object invoke(        Invocation invocation) throws Throwable {
          ((DependencyResolveContext)invocation.getParameter(0)).add(depFiles);
          return null;
        }
      }
);
      allowing(depFiles).getFiles();
      will(returnValue(toSet(depFile)));
    }
  }
);
  assertThat(actualResolvedConfiguration.getFiles(Specs.SATISFIES_ALL),equalTo(toLinkedSet(depFile,configFile)));
}
