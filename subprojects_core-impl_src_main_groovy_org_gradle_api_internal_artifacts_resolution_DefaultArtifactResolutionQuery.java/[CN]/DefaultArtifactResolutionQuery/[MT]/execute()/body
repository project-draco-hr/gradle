{
  List<ResolutionAwareRepository> repositories=CollectionUtils.collect(repositoryHandler,Transformers.cast(ResolutionAwareRepository.class));
  ConfigurationInternal configuration=configurationContainer.detachedConfiguration();
  final RepositoryChain repositoryChain=ivyFactory.create(configuration,repositories,metadataProcessor);
  return lockingManager.useCache("resolve artifacts",new Factory<ArtifactResolutionQueryResult>(){
    public ArtifactResolutionQueryResult create(){
      Set<JvmLibrary> jvmLibraries=Sets.newHashSet();
      Set<UnresolvedSoftwareComponent> unresolvedComponents=Sets.newHashSet();
      for (      ComponentIdentifier componentId : componentIds) {
        if (!(componentId instanceof ModuleComponentIdentifier)) {
          throw new IllegalArgumentException(String.format("Cannot resolve the artifacts for component %s with unsupported type %s.",componentId.getDisplayName(),componentId.getClass().getName()));
        }
        ModuleComponentIdentifier moduleComponentId=(ModuleComponentIdentifier)componentId;
        BuildableComponentResolveResult moduleResolveResult=new DefaultBuildableComponentResolveResult();
        repositoryChain.getDependencyResolver().resolve(new DefaultDependencyMetaData(new DefaultDependencyDescriptor(toModuleRevisionId(moduleComponentId),true)),moduleResolveResult);
        ArtifactResolver artifactResolver=new ErrorHandlingArtifactResolver(repositoryChain.getArtifactResolver());
        if (moduleResolveResult.getFailure() != null) {
          unresolvedComponents.add(new DefaultUnresolvedSoftwareComponent(moduleComponentId,moduleResolveResult.getFailure()));
        }
 else {
          ComponentMetaData component=moduleResolveResult.getMetaData();
          List<JvmLibraryArtifact> jvmLibraryArtifacts=Lists.newArrayList();
          for (          Class<? extends SoftwareArtifact> artifactType : artifactTypes) {
            ArtifactResolveContext context=new ArtifactTypeResolveContext(artifactType);
            BuildableArtifactSetResolveResult multiResolveResult=new DefaultBuildableArtifactSetResolveResult();
            artifactResolver.resolveModuleArtifacts(component,context,multiResolveResult);
            for (            ComponentArtifactMetaData artifactMetaData : multiResolveResult.getArtifacts()) {
              BuildableArtifactResolveResult resolveResult=new DefaultBuildableArtifactResolveResult();
              artifactResolver.resolveArtifact(artifactMetaData,component.getSource(),resolveResult);
              if (artifactType == JvmLibraryJavadocArtifact.class) {
                if (resolveResult.getFailure() != null) {
                  jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFailure()));
                }
 else {
                  jvmLibraryArtifacts.add(new DefaultJvmLibraryJavadocArtifact(resolveResult.getFile()));
                }
              }
 else               if (artifactType == JvmLibrarySourcesArtifact.class) {
                if (resolveResult.getFailure() != null) {
                  jvmLibraryArtifacts.add(new DefaultJvmLibrarySourcesArtifact(resolveResult.getFailure()));
                }
 else {
                  jvmLibraryArtifacts.add(new DefaultJvmLibrarySourcesArtifact(resolveResult.getFile()));
                }
              }
 else {
                throw new IllegalArgumentException(String.format("Cannot resolve artifacts with unsupported type %s.",artifactType.getName()));
              }
            }
          }
          jvmLibraries.add(new DefaultJvmLibrary(moduleComponentId,jvmLibraryArtifacts));
        }
      }
      return new DefaultArtifactResolutionQueryResult(jvmLibraries,unresolvedComponents);
    }
  }
);
}
