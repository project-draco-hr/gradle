{
  LOGGER.debug("Attempting to transition model element '{}' to {}",target.path,target.state.name());
  Map<NodeState,NodeStateTransition> nodes=new HashMap<NodeState,NodeStateTransition>();
  LinkedList<NodeStateTransition> queue=new LinkedList<NodeStateTransition>();
  NodeStateTransition targetTransition=new NodeStateTransition(target);
  nodes.put(target,targetTransition);
  queue.add(targetTransition);
  while (!queue.isEmpty()) {
    NodeStateTransition transition=queue.getFirst();
    if (transition.state == NodeStateTransition.State.Achieved) {
      queue.removeFirst();
      continue;
    }
    if (transition.state == NodeStateTransition.State.VisitingInputs) {
      ModelNodeInternal node=transition.node;
      LOGGER.debug("Transition model element '{}' from {} to {}",node.getPath(),node.getState(),transition.getTargetState());
      apply(transition);
      transition.state=NodeStateTransition.State.Achieved;
      queue.removeFirst();
      continue;
    }
    if (transition.state == NodeStateTransition.State.NotSeen) {
      ModelNodeInternal node=modelGraph.find(transition.getPath());
      if (node != null) {
        int diff=node.getState().compareTo(transition.getTargetState());
        if (diff > 0) {
          throw new IllegalStateException(String.format("Cannot transition model element '%s' to state %s as it is already at state %s.",node.getPath(),transition.target.state,node.getState()));
        }
        if (diff == 0) {
          transition.state=NodeStateTransition.State.Achieved;
          queue.removeFirst();
          continue;
        }
      }
      attachPredecessor(transition);
      transition.state=NodeStateTransition.State.VisitingPredecessor;
    }
 else     if (transition.state == NodeStateTransition.State.VisitingPredecessor) {
      ModelNodeInternal node=modelGraph.find(transition.getPath());
      if (node == null) {
        throw new IllegalStateException(String.format("Model element '%s' does not exist.",transition.getPath()));
      }
      transition.node=node;
      attachInputs(transition);
      transition.state=NodeStateTransition.State.VisitingInputs;
    }
    for (    NodeState dependency : transition.dependencies) {
      NodeStateTransition dependencyTransition=nodes.get(dependency);
      if (dependencyTransition == null) {
        dependencyTransition=new NodeStateTransition(dependency);
        nodes.put(dependency,dependencyTransition);
      }
      queue.addFirst(dependencyTransition);
    }
  }
}
