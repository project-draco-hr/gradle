{
  if (binders.isEmpty()) {
    return;
  }
  while (!binders.isEmpty()) {
    for (    ModelPath scope : getBinderScopesWithUnboundByTypeReferences()) {
      selfCloseAllComponents(scope);
    }
    Iterable<ModelPath> unboundPaths=Iterables.concat(Iterables.transform(binders,new Function<RuleBinder<?>,Iterable<ModelPath>>(){
      public Iterable<ModelPath> apply(      RuleBinder<?> input){
        return input.getUnboundPaths();
      }
    }
));
    ModelPath unboundPath=Iterables.getFirst(unboundPaths,null);
    if (unboundPath != null) {
      ModelNode selfClosedParent=selfCloseAllComponents(unboundPath.getParent());
      if (selfClosedParent == null || modelGraph.find(unboundPath) == null) {
        break;
      }
    }
 else {
      break;
    }
  }
  if (!binders.isEmpty()) {
    ModelPathSuggestionProvider suggestionsProvider=new ModelPathSuggestionProvider(Iterables.concat(modelGraph.getFlattened().keySet(),creators.keySet()));
    List<? extends UnboundRule> unboundRules=new UnboundRulesProcessor(binders,suggestionsProvider).process();
    throw new UnboundModelRulesException(unboundRules);
  }
}
