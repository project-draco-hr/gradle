{
  for (  ModelMutator<?> mutator : mutators) {
    ModelType<?> mutationTargetType=mutator.getReference().getType();
    if (mutationTargetType.isAssignableFrom(model.getReference().getType())) {
      @SuppressWarnings("unchecked") ModelMutator<? super T> castMutator=(ModelMutator<? super T>)mutator;
      fireMutation(model,castMutator);
      List<ModelPath> inputPaths=Lists.transform(mutator.getInputBindings(),new Function<ModelReference<?>,ModelPath>(){
        @Nullable public ModelPath apply(        ModelReference<?> input){
          return input.getPath();
        }
      }
);
      used.put(model.getReference().getPath(),inputPaths);
    }
 else {
      throw new IllegalArgumentException("Cannot fire mutation rule " + mutator + " for "+ model+ " due to incompatible types");
    }
  }
}
