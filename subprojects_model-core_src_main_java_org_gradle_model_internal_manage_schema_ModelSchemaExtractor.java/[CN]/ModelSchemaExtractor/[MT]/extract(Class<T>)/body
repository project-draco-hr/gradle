{
  validateType(type);
  List<Method> methodList=Arrays.asList(type.getDeclaredMethods());
  if (methodList.isEmpty()) {
    return new ModelSchema<T>(type,Collections.<ModelProperty<?>>emptyList());
  }
  List<ModelProperty<?>> properties=Lists.newLinkedList();
  Map<String,Method> methods=Maps.newHashMap();
  for (  Method method : methodList) {
    String name=method.getName();
    if (methods.containsKey(name)) {
      throw invalidMethod(type,name,"overloaded methods are not supported");
    }
    methods.put(name,method);
  }
  List<String> methodNames=Lists.newLinkedList(methods.keySet());
  List<String> handled=Lists.newArrayList();
  for (ListIterator<String> iterator=methodNames.listIterator(); iterator.hasNext(); ) {
    String methodName=iterator.next();
    Method method=methods.get(methodName);
    if (methodName.startsWith("get") && !methodName.equals("get")) {
      if (method.getParameterTypes().length != 0) {
        throw invalidMethod(type,methodName,"getter methods cannot take parameters");
      }
      Class<?> returnType=method.getReturnType();
      if (!returnType.equals(String.class)) {
        throw invalidMethod(type,methodName,"only String properties are supported");
      }
      ModelType<String> propertyType=ModelType.of(String.class);
      Character getterPropertyNameFirstChar=methodName.charAt(3);
      if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
        throw invalidMethod(type,methodName,"the 4th character of the getter method name must be an uppercase character");
      }
      String propertyNameCapitalized=methodName.substring(3);
      String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
      String setterName="set" + propertyNameCapitalized;
      if (!methods.containsKey(setterName)) {
        throw invalidMethod(type,methodName,"no corresponding setter for getter");
      }
      Method setter=methods.get(setterName);
      handled.add(setterName);
      if (!setter.getReturnType().equals(void.class)) {
        throw invalidMethod(type,setterName,"setter method must have void return type");
      }
      Type[] setterParameterTypes=setter.getGenericParameterTypes();
      if (setterParameterTypes.length != 1) {
        throw invalidMethod(type,setterName,"setter method must have exactly one parameter");
      }
      ModelType<?> setterType=ModelType.of(setterParameterTypes[0]);
      if (!setterType.equals(propertyType)) {
        throw invalidMethod(type,setterName,"setter method param must be of exactly the same type as the getter returns (expected: " + propertyType + ", found: "+ setterType+ ")");
      }
      properties.add(new ModelProperty<String>(propertyName,propertyType));
      iterator.remove();
    }
  }
  methodNames.removeAll(handled);
  if (!methodNames.isEmpty()) {
    throw invalid(type,"only paired getter/setter methods are supported (invalid methods: [" + Joiner.on(", ").join(methodNames) + "])");
  }
  return new ModelSchema<T>(type,properties);
}
