{
  Map<Class,Class> cache=GENERATED_CLASSES.get(getClass());
  if (cache == null) {
    cache=new HashMap<Class,Class>();
    GENERATED_CLASSES.put(getClass(),cache);
  }
  Class generatedClass=cache.get(type);
  if (generatedClass != null) {
    return generatedClass;
  }
  if (Modifier.isPrivate(type.getModifiers())) {
    throw new GradleException(String.format("Cannot create a proxy class for private class '%s'.",type.getSimpleName()));
  }
  if (Modifier.isAbstract(type.getModifiers())) {
    throw new GradleException(String.format("Cannot create a proxy class for abstract class '%s'.",type.getSimpleName()));
  }
  Class<? extends T> subclass;
  try {
    ClassBuilder<T> builder=start(type);
    boolean isConventionAware=type.getAnnotation(NoConventionMapping.class) == null;
    boolean isDynamicAware=type.getAnnotation(NoDynamicObject.class) == null;
    builder.startClass(isConventionAware,isDynamicAware);
    if (isDynamicAware && !DynamicObjectAware.class.isAssignableFrom(type)) {
      if (ExtensionAware.class.isAssignableFrom(type)) {
        throw new UnsupportedOperationException("A type that implements ExtensionAware must currently also implement DynamicObjectAware.");
      }
      builder.mixInDynamicAware();
    }
    if (isDynamicAware && !GroovyObject.class.isAssignableFrom(type)) {
      builder.mixInGroovyObject();
    }
    if (isDynamicAware) {
      builder.addDynamicMethods();
    }
    if (isConventionAware && !IConventionAware.class.isAssignableFrom(type)) {
      builder.mixInConventionAware();
    }
    Class noMappingClass=Object.class;
    for (Class<?> c=type; c != null && noMappingClass == Object.class; c=c.getSuperclass()) {
      if (c.getAnnotation(NoConventionMapping.class) != null) {
        noMappingClass=c;
      }
    }
    Collection<String> skipProperties=Arrays.asList("metaClass","conventionMapping","convention","asDynamicObject","extensions");
    MetaClass metaClass=GroovySystem.getMetaClassRegistry().getMetaClass(type);
    for (    MetaProperty property : metaClass.getProperties()) {
      if (skipProperties.contains(property.getName())) {
        continue;
      }
      if (property instanceof MetaBeanProperty) {
        MetaBeanProperty metaBeanProperty=(MetaBeanProperty)property;
        boolean needsConventionMapping=true;
        MetaMethod getter=metaBeanProperty.getGetter();
        if (getter == null) {
          needsConventionMapping=false;
        }
 else {
          if (Modifier.isFinal(getter.getModifiers()) || Modifier.isPrivate(getter.getModifiers())) {
            needsConventionMapping=false;
          }
 else           if (getter.getReturnType().isPrimitive()) {
            needsConventionMapping=false;
          }
 else {
            Class declaringClass=getter.getDeclaringClass().getTheClass();
            if (declaringClass.isAssignableFrom(noMappingClass)) {
              needsConventionMapping=false;
            }
          }
        }
        if (needsConventionMapping) {
          builder.addGetter(metaBeanProperty);
        }
        MetaMethod setter=metaBeanProperty.getSetter();
        if (setter == null || Modifier.isPrivate(setter.getModifiers())) {
          continue;
        }
        if (needsConventionMapping && !Modifier.isFinal(setter.getModifiers())) {
          builder.addSetter(metaBeanProperty);
        }
        if (Iterable.class.isAssignableFrom(property.getType())) {
          continue;
        }
        boolean hasSetMethod=false;
        for (        MetaMethod metaMethod : metaClass.getMethods()) {
          if (metaMethod.getName().equals(property.getName()) && metaMethod.getParameterTypes().length == 1) {
            builder.overrideSetMethod(metaBeanProperty,metaMethod);
            hasSetMethod=true;
          }
        }
        if (!hasSetMethod) {
          builder.addSetMethod(metaBeanProperty);
        }
      }
    }
    for (    Constructor<?> constructor : type.getConstructors()) {
      if (Modifier.isPublic(constructor.getModifiers())) {
        builder.addConstructor(constructor);
      }
    }
    subclass=builder.generate();
  }
 catch (  Throwable e) {
    throw new GradleException(String.format("Could not generate a proxy class for class %s.",type.getName()),e);
  }
  cache.put(type,subclass);
  cache.put(subclass,subclass);
  return subclass;
}
