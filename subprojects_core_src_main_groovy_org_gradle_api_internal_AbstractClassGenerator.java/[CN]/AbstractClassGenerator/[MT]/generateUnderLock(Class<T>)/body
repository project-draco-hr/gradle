{
  Map<Class<?>,Class<?>> cache=GENERATED_CLASSES.get(getClass());
  if (cache == null) {
    cache=new ReferenceMap(AbstractReferenceMap.WEAK,AbstractReferenceMap.WEAK);
    GENERATED_CLASSES.put(getClass(),cache);
  }
  Class<?> generatedClass=cache.get(type);
  if (generatedClass != null) {
    return generatedClass.asSubclass(type);
  }
  if (Modifier.isPrivate(type.getModifiers())) {
    throw new GradleException(String.format("Cannot create a proxy class for private class '%s'.",type.getSimpleName()));
  }
  if (Modifier.isAbstract(type.getModifiers())) {
    throw new GradleException(String.format("Cannot create a proxy class for abstract class '%s'.",type.getSimpleName()));
  }
  Class<? extends T> subclass;
  try {
    ClassBuilder<T> builder=start(type);
    boolean isConventionAware=type.getAnnotation(NoConventionMapping.class) == null;
    builder.startClass(isConventionAware);
    if (!DynamicObjectAware.class.isAssignableFrom(type)) {
      if (ExtensionAware.class.isAssignableFrom(type)) {
        throw new UnsupportedOperationException("A type that implements ExtensionAware must currently also implement DynamicObjectAware.");
      }
      builder.mixInDynamicAware();
    }
    if (!GroovyObject.class.isAssignableFrom(type)) {
      builder.mixInGroovyObject();
    }
    builder.addDynamicMethods();
    if (isConventionAware && !IConventionAware.class.isAssignableFrom(type)) {
      builder.mixInConventionAware();
    }
    Class noMappingClass=Object.class;
    for (Class<?> c=type; c != null && noMappingClass == Object.class; c=c.getSuperclass()) {
      if (c.getAnnotation(NoConventionMapping.class) != null) {
        noMappingClass=c;
      }
    }
    Set<PropertyMetaData> settableProperties=new HashSet<PropertyMetaData>();
    Set<PropertyMetaData> conventionProperties=new HashSet<PropertyMetaData>();
    ClassMetaData classMetaData=inspectType(type);
    for (    PropertyMetaData property : classMetaData.properties.values()) {
      if (SKIP_PROPERTIES.contains(property.name)) {
        continue;
      }
      boolean needsConventionMapping=true;
      Method getter=property.getter;
      if (getter == null) {
        needsConventionMapping=false;
      }
 else {
        if (Modifier.isFinal(getter.getModifiers())) {
          needsConventionMapping=false;
        }
 else {
          Class<?> declaringClass=getter.getDeclaringClass();
          if (declaringClass.isAssignableFrom(noMappingClass)) {
            needsConventionMapping=false;
          }
        }
      }
      if (needsConventionMapping) {
        conventionProperties.add(property);
        builder.addGetter(property);
      }
      Method setter=property.setter;
      if (setter == null) {
        continue;
      }
      if (needsConventionMapping && !Modifier.isFinal(setter.getModifiers())) {
        builder.addSetter(property);
      }
      if (Iterable.class.isAssignableFrom(property.getType())) {
        continue;
      }
      settableProperties.add(property);
    }
    Set<Method> actionMethods=classMetaData.missingOverloads;
    for (    Method method : actionMethods) {
      builder.addActionMethod(method);
    }
    for (    PropertyMetaData property : settableProperties) {
      if (property.setMethods.isEmpty()) {
        builder.addSetMethod(property);
      }
 else       if (conventionProperties.contains(property)) {
        for (        Method setMethod : property.setMethods) {
          builder.overrideSetMethod(property,setMethod);
        }
      }
    }
    for (    Constructor<?> constructor : type.getConstructors()) {
      if (Modifier.isPublic(constructor.getModifiers())) {
        builder.addConstructor(constructor);
      }
    }
    subclass=builder.generate();
  }
 catch (  Throwable e) {
    throw new GradleException(String.format("Could not generate a proxy class for class %s.",type.getName()),e);
  }
  cache.put(type,subclass);
  cache.put(subclass,subclass);
  return subclass;
}
