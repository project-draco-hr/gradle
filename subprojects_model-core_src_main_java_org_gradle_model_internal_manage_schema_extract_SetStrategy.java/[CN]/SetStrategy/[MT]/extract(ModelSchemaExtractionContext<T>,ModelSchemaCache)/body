{
  ModelType<T> type=extractionContext.getType();
  if (modelType.isAssignableFrom(type)) {
    if (!type.getRawClass().equals(modelType.getConcreteClass())) {
      throw new InvalidManagedModelElementTypeException(extractionContext,String.format("subtyping %s is not supported",modelType.getConcreteClass().getName()));
    }
    if (type.isHasWildcardTypeVariables()) {
      throw new InvalidManagedModelElementTypeException(extractionContext,String.format("type parameter of %s cannot be a wildcard",modelType.getConcreteClass().getName()));
    }
    List<ModelType<?>> typeVariables=type.getTypeVariables();
    if (typeVariables.isEmpty()) {
      throw new InvalidManagedModelElementTypeException(extractionContext,String.format("type parameter of %s has to be specified",modelType.getConcreteClass().getName()));
    }
    ModelType<?> elementType=typeVariables.get(0);
    if (modelType.isAssignableFrom(elementType)) {
      throw new InvalidManagedModelElementTypeException(extractionContext,String.format("%1$s cannot be used as type parameter of %1$s",modelType.getConcreteClass().getName()));
    }
    ModelSchema<T> schema=ModelSchema.collection(extractionContext.getType(),elementType);
    ModelSchemaExtractionContext<?> typeParamExtractionContext=extractionContext.child(elementType,"element type",new Action<ModelSchemaExtractionContext<?>>(){
      public void execute(      ModelSchemaExtractionContext<?> context){
        ModelSchema<?> typeParamSchema=cache.get(context.getType());
        if (!typeParamSchema.getKind().isManaged()) {
          throw new InvalidManagedModelElementTypeException(context.getParent(),String.format("cannot create a managed set of type %s as it is an unmanaged type. Only @Managed types are allowed.",context.getType()));
        }
      }
    }
);
    return new ModelSchemaExtractionResult<T>(schema,ImmutableList.of(typeParamExtractionContext));
  }
 else {
    return null;
  }
}
