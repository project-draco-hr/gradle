{
  Constructor<?>[] constructors=type.getDeclaredConstructors();
  Constructor<?> defaultConstructor=null;
  List<Constructor<?>> injectConstructors=new ArrayList<Constructor<?>>();
  for (  Constructor<?> constructor : constructors) {
    if (constructor.getAnnotation(Inject.class) != null) {
      injectConstructors.add(constructor);
    }
    if (constructor.getParameterTypes().length == 0) {
      defaultConstructor=constructor;
    }
  }
  if (injectConstructors.isEmpty() && constructors.length == 1 && defaultConstructor != null) {
    injectConstructors.add(defaultConstructor);
  }
  Constructor<?> parameterMatchConstructor=null;
  for (  Constructor<?> constructor : type.getConstructors()) {
    Class<?>[] parameterTypes=constructor.getParameterTypes();
    if (parameterTypes.length == parameters.length) {
      boolean match=true;
      for (int i=0; match && i < parameters.length; i++) {
        Class<?> targetType=parameterTypes[i];
        if (targetType.isPrimitive()) {
          targetType=JavaReflectionUtil.getWrapperTypeForPrimitiveType(targetType);
        }
        if (!targetType.isInstance(parameters[i])) {
          match=false;
        }
      }
      if (match) {
        if (parameterMatchConstructor != null) {
          throw new IllegalArgumentException(String.format("Class %s has multiple constructors that accept parameters %s.",type.getName(),Arrays.toString(parameters)));
        }
        parameterMatchConstructor=constructor;
      }
    }
  }
  if (parameterMatchConstructor == null && type.getConstructors().length == 1) {
    parameterMatchConstructor=type.getConstructors()[0];
  }
  if (parameterMatchConstructor == null) {
    if (injectConstructors.isEmpty()) {
      throw new IllegalArgumentException(String.format("Class %s has no constructor that accepts parameters %s or that is annotated with @Inject.",type.getName(),Arrays.toString(parameters)));
    }
    if (injectConstructors.size() > 1) {
      throw new IllegalArgumentException(String.format("Class %s has multiple constructors with @Inject annotation.",type.getName()));
    }
    return injectConstructors.get(0);
  }
  if (injectConstructors.isEmpty()) {
    if (type.getConstructors().length == 1) {
      onDeprecationWarning.execute(String.format("Constructor for class %s is not annotated with @Inject. In Gradle 2.0 this will be treated as an error.",type.getName()));
    }
 else {
      onDeprecationWarning.execute(String.format("Class %s has multiple constructors and no constructor is annotated with @Inject. In Gradle 2.0 this will be treated as an error.",type.getName()));
    }
  }
 else   if (injectConstructors.size() > 1) {
    onDeprecationWarning.execute(String.format("Class %s has multiple constructors with @Inject annotation. In Gradle 2.0 this will be treated as an error.",type.getName()));
  }
 else   if (!injectConstructors.get(0).equals(parameterMatchConstructor)) {
    onDeprecationWarning.execute(String.format("Class %s has @Inject annotation on an unexpected constructor. In Gradle 2.0 the constructor annotated with @Inject will be used instead of the current default constructor.",type.getName()));
  }
  return parameterMatchConstructor;
}
