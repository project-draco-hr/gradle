{
  lifecycleLock.lock();
  try {
    if (started) {
      throw new IllegalStateException("cannot start daemon as it is already running");
    }
    connectorAddress=connector.start(new IncomingConnectionHandler(){
      public void handle(      final Connection<Object> connection){
        handlersExecutor.execute(new Runnable(){
          public void run(){
            Command command=(Command)connection.receive();
            if (command == null) {
              LOGGER.warn("It seems the client dropped the connection before sending any command. Stopping connection.");
              connection.stop();
              return;
            }
            if (command instanceof Stop) {
              LOGGER.lifecycle("Stopping");
              connection.dispatch(new CommandComplete(null));
              stopLatch.countDown();
              stopperExecutor.stop();
              return;
            }
            try {
              control.onStartActivity();
            }
 catch (            BusyException e) {
              LOGGER.info("The daemon is busy and another build request received. Returning Busy response.");
              connection.dispatch(new CommandComplete(e));
              return;
            }
            try {
              doRun(connection,control,command);
            }
  finally {
              control.onActivityComplete();
              connection.stop();
            }
          }
        }
);
      }
    }
);
    control.setActivityListener(new CompletionHandler.ActivityListener(){
      public void onStartActivity(){
        try {
          LOGGER.info("Marking the daemon as busy, address: " + connectorAddress);
          daemonRegistry.markBusy(connectorAddress);
        }
 catch (        DaemonRegistry.EmptyRegistryException e) {
          LOGGER.warn("Cannot mark daemon as busy because the registry is empty.");
        }
catch (        Exception e) {
          LOGGER.error("Unable to mark busy",e);
        }
      }
      public void onCompleteActivity(){
        try {
          LOGGER.info("Marking the daemon as idle, address: " + connectorAddress);
          daemonRegistry.markIdle(connectorAddress);
        }
 catch (        DaemonRegistry.EmptyRegistryException e) {
          LOGGER.warn("Cannot mark daemon as idle because the registry is empty.");
        }
catch (        Exception e) {
          LOGGER.error("Unable to mark idle",e);
        }
      }
      public void onStart(){
        LOGGER.info("Advertising the daemon address to the clients: " + connectorAddress);
        daemonRegistry.store(connectorAddress);
      }
      public void onStop(){
        LOGGER.info("Removing our presence to clients, eg. removing this address from the registry: " + connectorAddress);
        try {
          daemonRegistry.remove(connectorAddress);
        }
 catch (        DaemonRegistry.EmptyRegistryException e) {
          LOGGER.warn("Cannot remove daemon from the registry because the registry is empty.");
        }
        LOGGER.info("Address removed from registry.");
      }
    }
);
    stopperExecutor.execute(new Runnable(){
      public void run(){
        try {
          stopLatch.await();
        }
 catch (        InterruptedException e) {
          return;
        }
        LOGGER.info("Stop requested. Daemon is stopping accepting new connections...");
        connector.stop();
        LOGGER.info("Waking and signalling stop to the main daemon thread...");
        control.stop();
      }
    }
);
    control.start();
    started=true;
    LOGGER.lifecycle("Daemon started at: " + new Date() + ", with address: "+ connectorAddress);
  }
 catch (  Exception e) {
    LOGGER.warn("exception starting daemon",e);
    stopLatch.countDown();
  }
 finally {
    lifecycleLock.unlock();
  }
}
