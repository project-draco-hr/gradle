{
  lock.lock();
  try {
    final Iterable<? extends File> roots=fileSystemSubset.getRoots();
    final FileSystemSubset unfiltered=fileSystemSubset.unfiltered();
    Iterable<? extends File> startingWatchPoints=calculateStartingWatchPoints(roots,unfiltered);
    if (currentRoots != null) {
      final ImmutableSet.Builder<File> newStartingPoints=ImmutableSet.builder();
      Iterable<? extends File> combinedRoots=FileUtils.calculateRoots(Iterables.concat(currentRoots,startingWatchPoints));
      for (      File file : combinedRoots) {
        if (!currentRoots.contains(file)) {
          newStartingPoints.add(file);
        }
      }
      startingWatchPoints=newStartingPoints.build();
      currentRoots=ImmutableSet.copyOf(combinedRoots);
      combinedFileSystemSubset=FileSystemSubset.builder().add(combinedFileSystemSubset).add(fileSystemSubset).build();
    }
 else {
      currentRoots=ImmutableSet.copyOf(startingWatchPoints);
      combinedFileSystemSubset=fileSystemSubset;
    }
    for (    File dir : startingWatchPoints) {
      if (FILE_TREE_WATCHING_SUPPORTED) {
        watchDir(dir.toPath());
      }
 else {
        Files.walkFileTree(dir.toPath(),new SimpleFileVisitor<Path>(){
          @Override public FileVisitResult preVisitDirectory(          Path path,          BasicFileAttributes attrs) throws IOException {
            if (inUnfilteredSubsetOrAncestorOfAnyRoot(path.toFile(),roots,unfiltered)) {
              watchDir(path);
              return FileVisitResult.CONTINUE;
            }
 else {
              return FileVisitResult.SKIP_SUBTREE;
            }
          }
        }
);
      }
    }
  }
  finally {
    lock.unlock();
  }
}
