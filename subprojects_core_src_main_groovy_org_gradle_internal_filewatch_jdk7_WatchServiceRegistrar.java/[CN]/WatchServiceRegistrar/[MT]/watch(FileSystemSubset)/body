{
  this.fileSystemSubset=fileSystemSubset;
  this.unfilteredFileSystemSubset=fileSystemSubset.unfiltered();
  this.roots=fileSystemSubset.getRoots();
  Iterable<File> enclosingDirsThatExist=Iterables.transform(roots,new Function<File,File>(){
    @Override public File apply(    File input){
      File target=input;
      while (!target.isDirectory()) {
        target=target.getParentFile();
      }
      return target;
    }
  }
);
  Iterable<? extends File> startingWatchPoints=FileUtils.calculateRoots(enclosingDirsThatExist);
  for (  File dir : startingWatchPoints) {
    if (FILE_TREE_WATCHING_SUPPORTED) {
      if (inUnfilteredSubsetOrAncestorOfAnyRoot(dir)) {
        watchDir(dir.toPath());
      }
    }
 else {
      Files.walkFileTree(dir.toPath(),new SimpleFileVisitor<Path>(){
        @Override public FileVisitResult preVisitDirectory(        Path path,        BasicFileAttributes attrs) throws IOException {
          if (inUnfilteredSubsetOrAncestorOfAnyRoot(path.toFile())) {
            watchDir(path);
            return FileVisitResult.CONTINUE;
          }
 else {
            return FileVisitResult.SKIP_SUBTREE;
          }
        }
      }
);
    }
  }
}
