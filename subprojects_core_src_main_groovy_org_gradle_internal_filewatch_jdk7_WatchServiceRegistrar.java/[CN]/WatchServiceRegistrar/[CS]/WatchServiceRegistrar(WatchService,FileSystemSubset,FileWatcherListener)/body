{
  this.watchService=watchService;
  this.fileSystemSubset=fileSystemSubset;
  this.unfilteredFileSystemSubset=fileSystemSubset.unfiltered();
  this.roots=fileSystemSubset.getRoots();
  this.delegate=delegate;
  Iterable<File> enclosingDirsThatExist=Iterables.transform(roots,new Function<File,File>(){
    @Override public File apply(    File input){
      File target=input;
      while (!target.isDirectory()) {
        target=target.getParentFile();
      }
      return target;
    }
  }
);
  Iterable<? extends File> startingWatchPoints=FileUtils.calculateRoots(enclosingDirsThatExist);
  for (  File dir : startingWatchPoints) {
    Files.walkFileTree(dir.toPath(),new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult preVisitDirectory(      Path path,      BasicFileAttributes attrs) throws IOException {
        if (inUnfilteredSubsetOrAncestorOfAnyRoot(path.toFile())) {
          watchDir(path);
          return FileVisitResult.CONTINUE;
        }
 else {
          return FileVisitResult.SKIP_SUBTREE;
        }
      }
    }
);
  }
}
