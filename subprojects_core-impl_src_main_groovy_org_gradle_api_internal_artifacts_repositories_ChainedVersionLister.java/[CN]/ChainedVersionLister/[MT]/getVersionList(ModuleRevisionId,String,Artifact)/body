{
  final Iterator<VersionLister> versionListerIterator=versionListers.iterator();
  while (versionListerIterator.hasNext()) {
    VersionLister lister=versionListerIterator.next();
    try {
      final VersionList versionList=lister.getVersionList(moduleRevisionId,pattern,artifact);
      if (!versionListerIterator.hasNext() || !versionList.isEmpty()) {
        return versionList;
      }
    }
 catch (    ResourceNotFoundException e) {
      if (!versionListerIterator.hasNext()) {
        throw new ResourceNotFoundException(String.format("Failed to list versions for %s using %s",moduleRevisionId,lister.getClass()),e);
      }
    }
catch (    ResourceException e) {
      if (versionListerIterator.hasNext()) {
        String deprecationMessage=String.format("Error listing versions of %s using %s. Will attempt an alternate way to list versions. " + "This behaviour is deprecated: in a future version of Gradle, this build will fail.",moduleRevisionId,lister.getClass());
        DeprecationLogger.nagUserWith(deprecationMessage);
        LOGGER.debug(deprecationMessage,e);
      }
 else {
        throw new ResourceException(String.format("Failed to list versions for %s using %s",moduleRevisionId,lister.getClass()),e);
      }
    }
  }
  return new DefaultVersionList(Collections.<String>emptyList());
}
