{
  List<TaskInfo> nodeQueue=new ArrayList<TaskInfo>(entryTasks);
  Set<TaskInfo> visitingNodes=new HashSet<TaskInfo>();
  Stack<GraphEdge> walkedShouldRunAfterEdges=new Stack<GraphEdge>();
  Stack<TaskInfo> path=new Stack<TaskInfo>();
  HashMap<TaskInfo,Integer> planBeforeVisiting=new HashMap<TaskInfo,Integer>();
  while (!nodeQueue.isEmpty()) {
    TaskInfo taskNode=nodeQueue.get(0);
    if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) {
      nodeQueue.remove(0);
      continue;
    }
    if (visitingNodes.add(taskNode)) {
      recordEdgeIfArrivedViaShouldRunAfter(walkedShouldRunAfterEdges,path,taskNode);
      removeShouldRunAfterSuccessorsIfTheyImposeACycle(visitingNodes,taskNode);
      takePlanSnapshotIfCanBeRestoredToCurrentTask(planBeforeVisiting,taskNode);
      ArrayList<TaskInfo> successors=new ArrayList<TaskInfo>();
      addAllSuccessorsInReverseOrder(taskNode,successors);
      for (      TaskInfo successor : successors) {
        if (visitingNodes.contains(successor)) {
          if (!walkedShouldRunAfterEdges.empty()) {
            GraphEdge toBeRemoved=walkedShouldRunAfterEdges.pop();
            toBeRemoved.from.removeShouldRunAfterSuccessor(toBeRemoved.to);
            restorePath(path,toBeRemoved);
            restoreQueue(nodeQueue,visitingNodes,toBeRemoved);
            restoreExecutionPlan(planBeforeVisiting,toBeRemoved);
            break;
          }
 else {
            onOrderingCycle();
          }
        }
        nodeQueue.add(0,successor);
      }
      path.push(taskNode);
    }
 else {
      nodeQueue.remove(0);
      visitingNodes.remove(taskNode);
      path.pop();
      executionPlan.put(taskNode.getTask(),taskNode);
      ArrayList<TaskInfo> finalizerTasks=new ArrayList<TaskInfo>();
      addAllReversed(finalizerTasks,taskNode.getFinalizers());
      for (      TaskInfo finalizer : finalizerTasks) {
        if (!visitingNodes.contains(finalizer) && !nodeQueue.contains(finalizer)) {
          nodeQueue.add(finalizerTaskPosition(finalizer,nodeQueue),finalizer);
        }
      }
    }
  }
}
