{
  executionPlan.clear();
  List<TaskDependencyGraphNode> nodeQueue=new ArrayList<TaskDependencyGraphNode>(graph.getNodesWithoutIncomingEdges());
  if (nodeQueue.isEmpty()) {
    throw new CircularReferenceException("Circular dependency between tasks.");
  }
  Set<TaskDependencyGraphNode> visitingNodes=new HashSet<TaskDependencyGraphNode>();
  while (!nodeQueue.isEmpty()) {
    TaskDependencyGraphNode taskNode=nodeQueue.get(0);
    if (!filter.isSatisfiedBy(taskNode.getTask())) {
      nodeQueue.remove(0);
      continue;
    }
    if (executionPlan.containsKey(taskNode.getTask())) {
      nodeQueue.remove(0);
      continue;
    }
    if (visitingNodes.add(taskNode)) {
      Set<TaskDependencyGraphNode> dependsOnTasks=new TreeSet<TaskDependencyGraphNode>(Collections.reverseOrder());
      dependsOnTasks.addAll(taskNode.getSuccessors());
      dependsOnTasks=CollectionUtils.filter(dependsOnTasks,new Spec<TaskDependencyGraphNode>(){
        public boolean isSatisfiedBy(        TaskDependencyGraphNode element){
          return element.getRequired();
        }
      }
);
      for (      TaskDependencyGraphNode dependsOnTask : dependsOnTasks) {
        if (visitingNodes.contains(dependsOnTask)) {
          throw new CircularReferenceException(String.format("Circular dependency between tasks. Cycle includes [%s, %s].",taskNode.getTask(),dependsOnTask.getTask()));
        }
        nodeQueue.add(0,dependsOnTask);
      }
    }
 else {
      nodeQueue.remove(0);
      visitingNodes.remove(taskNode);
      Set<TaskInfo> dependencies=new HashSet<TaskInfo>();
      for (      TaskDependencyGraphNode dependency : taskNode.getSuccessors()) {
        TaskInfo dependencyInfo=executionPlan.get(dependency.getTask());
        if (dependencyInfo != null) {
          dependencies.add(dependencyInfo);
        }
      }
      executionPlan.put(taskNode.getTask(),new TaskInfo((TaskInternal)taskNode.getTask(),dependencies));
    }
  }
}
