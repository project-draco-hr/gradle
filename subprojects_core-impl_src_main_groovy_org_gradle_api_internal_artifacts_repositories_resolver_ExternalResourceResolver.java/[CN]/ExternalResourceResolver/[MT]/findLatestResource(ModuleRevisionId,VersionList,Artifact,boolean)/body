{
  String name=getName();
  ModuleVersionIdentifier requestedVersion=DefaultModuleVersionIdentifier.newId(mrid);
  for (  VersionList.ListedVersion listedVersion : versions.sortLatestFirst(getLatestStrategy())) {
    String version=listedVersion.getVersion();
    ModuleRevisionId foundMrid=ModuleRevisionId.newInstance(mrid,version);
    ModuleVersionIdentifier foundVersion=DefaultModuleVersionIdentifier.newId(foundMrid);
    if (!getVersionMatcher().accept(requestedVersion,foundVersion)) {
      LOGGER.debug(name + ": rejected by version matcher: " + version);
      continue;
    }
    boolean needsMetadata=getVersionMatcher().needModuleMetadata(requestedVersion,foundVersion);
    artifact=DefaultArtifact.cloneWithAnotherMrid(artifact,foundMrid);
    String resourcePath=listedVersion.getPattern().toPath(artifact);
    ExternalResource resource=getResource(resourcePath,artifact.getId(),forDownload || needsMetadata);
    String description=version + " [" + resource+ "]";
    if (!resource.exists()) {
      LOGGER.debug(name + ": unreachable: " + description);
      discardResource(resource);
      continue;
    }
    if (needsMetadata) {
      MutableModuleVersionMetaData metaData=getArtifactMetadata(artifact,resource);
      if (metaData == null) {
        LOGGER.debug(name + ": impossible to get module descriptor resource: " + description);
        discardResource(resource);
        continue;
      }
      metadataProcessor.process(new ModuleDetailsAdapter(metaData));
      if (!getVersionMatcher().accept(requestedVersion,metaData)) {
        LOGGER.debug(name + ": md rejected by version matcher: " + description);
        discardResource(resource);
        continue;
      }
      return new DownloadedAndParsedMetaDataArtifact(resource,artifact,metaData);
    }
    return new ResolvedArtifact(resource,artifact);
  }
  return null;
}
