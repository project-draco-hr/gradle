{
  File destinationDir=spec.getDestinationDir();
  ScalaCompileOptionsInternal scalaCompileOptions=(ScalaCompileOptionsInternal)spec.getScalaCompileOptions();
  String backend=chooseBackend(spec);
  ImmutableMap.Builder<String,Object> optionsBuilder=ImmutableMap.builder();
  optionsBuilder.put("destDir",destinationDir);
  optionsBuilder.put("target",backend);
  optionsBuilder.putAll(scalaCompileOptions.optionMap());
  if (scalaCompileOptions.internalIsFork()) {
    optionsBuilder.put("compilerPath",GUtil.asPath(scalaClasspath));
  }
  final ImmutableMap<String,Object> options=optionsBuilder.build();
  final String taskName=scalaCompileOptions.internalUseCompileDaemon() ? "fsc" : "scalac";
  final Iterable<File> compileClasspath=spec.getClasspath();
  LOGGER.info("Compiling with Ant scalac task.");
  LOGGER.debug("Ant scalac task options: {}",options);
  antBuilder.withClasspath(scalaClasspath).execute(new Closure<Object>(this){
    @SuppressWarnings("unused") public Object doCall(    final AntBuilderDelegate ant){
      ant.invokeMethod("taskdef",Collections.singletonMap("resource","scala/tools/ant/antlib.xml"));
      return ant.invokeMethod(taskName,new Object[]{options,new Closure<Void>(this){
        public void doCall(){
          spec.getSource().addToAntBuilder(ant,"src",FileCollection.AntType.MatchingTask);
          for (          File file : compileClasspath) {
            ant.invokeMethod("classpath",Collections.singletonMap("location",file));
          }
        }
      }
});
    }
  }
);
  return new SimpleWorkResult(true);
}
