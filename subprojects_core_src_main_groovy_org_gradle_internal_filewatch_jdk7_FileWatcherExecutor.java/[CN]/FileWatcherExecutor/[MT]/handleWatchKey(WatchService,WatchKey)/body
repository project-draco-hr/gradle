{
  Path watchedPath=(Path)watchKey.watchable();
  DirectoryTree watchedTree=pathToDirectoryTree.get(watchedPath);
  Set<File> individualFiles=individualFilesByParentPath.get(watchedPath);
  for (  WatchEvent<?> event : watchKey.pollEvents()) {
    WatchEvent.Kind kind=event.kind();
    if (kind == OVERFLOW) {
      changesNotifier.addPendingChange();
      continue;
    }
    if (kind.type() == Path.class) {
      WatchEvent<Path> ev=Cast.uncheckedCast(event);
      Path relativePath=ev.context();
      Path fullPath=watchedPath.resolve(relativePath);
      if (watchedTree != null) {
        FileTreeElement fileTreeElement=toFileTreeElement(fullPath,dirToPath(watchedTree.getDir()).relativize(fullPath));
        if (!watchedTree.getPatterns().getAsExcludeSpec().isSatisfiedBy(fileTreeElement)) {
          boolean isDirectory=Files.isDirectory(fullPath,NOFOLLOW_LINKS);
          if (kind == ENTRY_CREATE) {
            if (isDirectory) {
              boolean containsValidFiles=false;
              if (!supportsWatchingSubTree()) {
                try {
                  containsValidFiles=registerSubTree(watchService,fullPath,watchedTree);
                }
 catch (                IOException e) {
                  LOGGER.warn("IOException in registering sub tree " + fullPath.toString(),e);
                }
              }
 else {
                try {
                  containsValidFiles=doesTreeContainValidFiles(fullPath,watchedTree);
                }
 catch (                IOException e) {
                  LOGGER.warn("IOException in scanning sub tree for files " + fullPath.toString(),e);
                }
              }
              if (containsValidFiles) {
                changesNotifier.addPendingChange();
              }
            }
          }
          if (!isDirectory && watchedTree.getPatterns().getAsIncludeSpec().isSatisfiedBy(fileTreeElement)) {
            changesNotifier.addPendingChange();
          }
        }
      }
 else       if (individualFiles != null) {
        File fullFile=fullPath.toFile().getAbsoluteFile();
        if (individualFiles.contains(fullFile)) {
          changesNotifier.addPendingChange();
        }
      }
 else {
        LOGGER.warn("WatchEvent received on unmapped path " + fullPath.toString());
      }
    }
  }
  watchKey.reset();
}
