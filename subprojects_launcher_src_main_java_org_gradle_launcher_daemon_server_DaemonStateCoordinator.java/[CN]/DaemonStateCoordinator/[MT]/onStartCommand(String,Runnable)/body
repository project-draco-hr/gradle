{
  lock.lock();
  try {
switch (state) {
case Broken:
      throw new DaemonUnavailableException("This daemon is in a broken state and will stop.");
case StopRequested:
    throw new DaemonUnavailableException("This daemon is currently stopping.");
case Stopped:
  throw new DaemonUnavailableException("This daemon has stopped.");
}
if (currentCommandExecution != null) {
throw new DaemonUnavailableException(String.format("This daemon is currently executing: %s",currentCommandExecution));
}
LOGGER.debug("onStartCommand({}) called after {} minutes of idle",commandDisplayName,getIdleMinutes());
try {
onStartCommand.run();
currentCommandExecution=commandDisplayName;
this.onDisconnect=onDisconnect;
updateActivityTimestamp();
cancellationToken=new DefaultBuildCancellationToken();
condition.signalAll();
}
 catch (Throwable throwable) {
setState(State.Broken);
throw UncheckedException.throwAsUncheckedException(throwable);
}
}
  finally {
lock.unlock();
}
}
