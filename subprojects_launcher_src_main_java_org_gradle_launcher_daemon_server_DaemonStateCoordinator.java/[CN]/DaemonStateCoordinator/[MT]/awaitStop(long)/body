{
  lock.lock();
  try {
    LOGGER.debug("Idle timeout: waiting for daemon to stop or be idle for {}ms",timeoutMs);
    while (true) {
      try {
switch (state) {
case Running:
          if (isBusy()) {
            LOGGER.debug(DaemonMessages.DAEMON_BUSY);
            condition.await();
          }
 else           if (hasBeenIdleFor(timeoutMs)) {
            LOGGER.debug("Idle timeout: daemon has been idle for requested period. Stopping now.");
            stopNow("idle timeout");
            return false;
          }
 else {
            Date waitUntil=new Date(lastActivityAt + timeoutMs);
            LOGGER.debug("{}{}",DaemonMessages.DAEMON_IDLE,waitUntil);
            condition.awaitUntil(waitUntil);
          }
        break;
case Broken:
      throw new IllegalStateException("This daemon is in a broken state.");
case StopRequested:
    LOGGER.debug("Idle timeout: daemon stop has been requested. Sleeping until state changes.");
  condition.await();
break;
case Stopped:
LOGGER.debug("Idle timeout: daemon has stopped.");
return true;
}
}
 catch (InterruptedException e) {
throw UncheckedException.throwAsUncheckedException(e);
}
}
}
  finally {
lock.unlock();
}
}
