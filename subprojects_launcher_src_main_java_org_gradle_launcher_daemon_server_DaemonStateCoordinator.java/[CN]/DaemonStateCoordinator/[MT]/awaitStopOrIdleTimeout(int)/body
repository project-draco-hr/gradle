{
  lock.lock();
  try {
    while (true) {
      if (isStopped()) {
        return true;
      }
 else       if (hasBeenIdleFor(timeout)) {
        return false;
      }
      try {
        if (!isStarted()) {
          condition.await();
        }
 else         if (isBusy()) {
          condition.await();
        }
 else         if (isIdle()) {
          Date waitUntil=new Date(lastActivityAt + timeout);
          condition.awaitUntil(waitUntil);
        }
 else {
          throw new IllegalStateException("waiting for daemon to stop or idle timeout, daemon has started but is not busy or idle, this shouldn't happen");
        }
      }
 catch (      InterruptedException e) {
        throw UncheckedException.asUncheckedException(e);
      }
    }
  }
  finally {
    lock.unlock();
  }
}
