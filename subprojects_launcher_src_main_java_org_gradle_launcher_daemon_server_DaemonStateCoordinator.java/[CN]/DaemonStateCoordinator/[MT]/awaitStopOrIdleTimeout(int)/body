{
  lock.lock();
  try {
    LOGGER.debug("waiting for daemon to stop or be idle for {}ms",timeout);
    while (true) {
      try {
switch (state) {
case NotStarted:
          LOGGER.debug("Daemon has not yet started, sleeping until state changes.");
        condition.await();
      break;
case Running:
    if (isBusy()) {
      LOGGER.debug("Daemon is busy, sleeping until state changes.");
      condition.await();
    }
 else     if (hasBeenIdleFor(timeout)) {
      LOGGER.debug("Daemon has been idle for requested period.");
      return false;
    }
 else {
      Date waitUntil=new Date(lastActivityAt + timeout);
      LOGGER.debug("Daemon is idle, sleeping until state change or idle timeout at {}",waitUntil);
      condition.awaitUntil(waitUntil);
    }
  break;
case StopRequested:
LOGGER.debug("Daemon is stopping, sleeping until state changes.");
condition.await();
break;
case Stopped:
LOGGER.debug("Daemon has stopped.");
return true;
}
}
 catch (InterruptedException e) {
throw UncheckedException.throwAsUncheckedException(e);
}
}
}
  finally {
lock.unlock();
}
}
