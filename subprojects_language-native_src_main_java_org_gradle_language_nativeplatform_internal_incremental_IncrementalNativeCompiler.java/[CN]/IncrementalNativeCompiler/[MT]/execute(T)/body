{
  final PersistentStateCache<CompilationState> compileStateCache=compilationStateCacheFactory.create(task.getPath());
  final IncrementalCompilation compilation=cacheAccess.useCache("process source files",new Factory<IncrementalCompilation>(){
    public IncrementalCompilation create(){
      DefaultSourceIncludesParser sourceIncludesParser=new DefaultSourceIncludesParser(sourceParser,importsAreIncludes);
      IncrementalCompileProcessor processor=createProcessor(compileStateCache,sourceIncludesParser,spec.getIncludeRoots(),spec.getIncrementalInputs());
      return processor.processSourceFiles(spec.getSourceFiles());
    }
  }
);
  spec.setSourceFileIncludes(mapIncludes(spec.getSourceFiles(),compilation.getFinalState()));
  if (sourceFilesUseMacroIncludes(spec.getSourceFiles(),compilation.getFinalState())) {
    logger.info("Some #include files could not be determined.  Falling back to slow path which includes all files in the include search path as inputs.");
    for (    final File includeRoot : spec.getIncludeRoots()) {
      spec.getIncrementalInputs().newInput(includeRoot);
    }
  }
  WorkResult workResult;
  if (spec.isIncrementalCompile()) {
    workResult=doIncrementalCompile(compilation,spec);
  }
 else {
    workResult=doCleanIncrementalCompile(spec);
  }
  cacheAccess.useCache("update compilation state",new Factory<Void>(){
    public Void create(){
      compileStateCache.set(compilation.getFinalState());
      return null;
    }
  }
);
  return workResult;
}
