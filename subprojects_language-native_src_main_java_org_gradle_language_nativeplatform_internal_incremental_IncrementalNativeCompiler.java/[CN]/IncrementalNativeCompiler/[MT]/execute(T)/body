{
  final PersistentStateCache<CompilationState> compileStateCache=compilationStateCacheFactory.create(task.getPath());
  final IncrementalCompilation compilation=cacheAccess.useCache("process source files",new Factory<IncrementalCompilation>(){
    public IncrementalCompilation create(){
      DefaultSourceIncludesParser sourceIncludesParser=new DefaultSourceIncludesParser(sourceParser,importsAreIncludes);
      IncrementalCompileProcessor processor=createProcessor(compileStateCache,sourceIncludesParser,spec.getIncludeRoots(),spec.getIncrementalInputs());
      return processor.processSourceFiles(spec.getSourceFiles());
    }
  }
);
  spec.setSourceFileIncludes(mapIncludes(spec.getSourceFiles(),compilation.getFinalState()));
  if (sourceFilesUseMacroIncludes(spec.getSourceFiles(),compilation.getFinalState())) {
    logger.info("The path to some #include files could not be determined.  Falling back to slow path which includes all files in the include search path as inputs for {}.",task.getName());
    for (    final File includeRoot : spec.getIncludeRoots()) {
      logger.info("adding files in {} to discovered inputs for {}",includeRoot,task.getName());
      new DirectoryFileTree(includeRoot).visit(new FileVisitor(){
        @Override public void visitDir(        FileVisitDetails dirDetails){
        }
        @Override public void visitFile(        FileVisitDetails fileDetails){
          ((IncrementalTaskInputsInternal)spec.getIncrementalInputs()).newInput(fileDetails.getFile());
        }
      }
);
    }
  }
  WorkResult workResult;
  if (spec.isIncrementalCompile()) {
    workResult=doIncrementalCompile(compilation,spec);
  }
 else {
    workResult=doCleanIncrementalCompile(spec);
  }
  cacheAccess.useCache("update compilation state",new Factory<Void>(){
    public Void create(){
      compileStateCache.set(compilation.getFinalState());
      return null;
    }
  }
);
  return workResult;
}
