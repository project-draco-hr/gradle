{
  ModelType<R> type=extractionContext.getType();
  if (type.getRawClass().isAnnotationPresent(Managed.class)) {
    validateType(type,extractionContext);
    TypeMethods typeMethods=TypeMethods.of(type);
    ensureNoOverloadedMethods(extractionContext,typeMethods);
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    List<Method> handled=Lists.newArrayListWithCapacity(type.getRawClass().getMethods().length);
    for (    String methodName : typeMethods.getNames()) {
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        if (typeMethods.getParameterTypes(methodName).length != 0) {
          throw invalidMethod(extractionContext,"getter methods cannot take parameters",typeMethods.getFirst(methodName));
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,"the 4th character of the getter method name must be an uppercase character",typeMethods.getFirst(methodName));
        }
        ModelType<?> returnType=ModelType.of(typeMethods.getGenericReturnType(methodName));
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        boolean isWritable=typeMethods.hasMethod(setterName);
        if (isWritable) {
          validateSetter(extractionContext,returnType,typeMethods.getFirst(setterName));
          handled.addAll(typeMethods.get(setterName));
        }
        properties.add(ModelProperty.of(returnType,propertyName,isWritable,typeMethods.getDeclaredBy(methodName)));
        handled.addAll(typeMethods.get(methodName));
      }
    }
    Iterable<Method> notHandled=Iterables.filter(typeMethods,Predicates.not(Predicates.in(handled)));
    if (!Iterables.isEmpty(notHandled)) {
      throw invalidMethods(extractionContext,"only paired getter/setter methods are supported",notHandled);
    }
    ModelSchema<R> schema=ModelSchema.struct(type,properties);
    Iterable<ModelSchemaExtractionContext<?>> propertyDependencies=Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toPropertyExtractionContext(extractionContext,property,cache);
      }
    }
);
    return new ModelSchemaExtractionResult<R>(schema,propertyDependencies);
  }
 else {
    return null;
  }
}
