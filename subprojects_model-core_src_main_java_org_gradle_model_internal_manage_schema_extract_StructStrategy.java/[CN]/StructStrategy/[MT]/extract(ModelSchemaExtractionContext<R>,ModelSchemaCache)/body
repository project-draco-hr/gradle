{
  ModelType<R> type=extractionContext.getType();
  if (type.getRawClass().isAnnotationPresent(Managed.class)) {
    validateType(type,extractionContext);
    List<Method> methods=CollectionUtils.dedup(Arrays.asList(type.getRawClass().getMethods()),new MethodSignatureEquivalence());
    if (methods.isEmpty()) {
      return new ModelSchemaExtractionResult<R>(ModelSchema.struct(type,Collections.<ModelProperty<?>>emptySet()));
    }
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    final ImmutableListMultimap<String,Method> methodsByName=Multimaps.index(methods,new Function<Method,String>(){
      public String apply(      Method method){
        return method.getName();
      }
    }
);
    ensureNoOverloadedMethods(extractionContext,methodsByName);
    List<Method> handled=Lists.newArrayListWithCapacity(methods.size());
    for (    Method method : methods) {
      String methodName=method.getName();
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        if (method.getParameterTypes().length != 0) {
          throw invalidMethod(extractionContext,"getter methods cannot take parameters",method);
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,"the 4th character of the getter method name must be an uppercase character",method);
        }
        ModelType<?> returnType=ModelType.of(method.getGenericReturnType());
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        boolean isWritable=methodsByName.containsKey(setterName);
        if (isWritable) {
          Method setter=methodsByName.get(setterName).get(0);
          validateSetter(extractionContext,returnType,setter);
          handled.add(setter);
        }
        properties.add(ModelProperty.of(returnType,propertyName,isWritable,ModelType.of(method.getDeclaringClass())));
        handled.add(method);
      }
    }
    Iterable<Method> notHandled=Iterables.filter(methods,Predicates.not(Predicates.in(handled)));
    if (!Iterables.isEmpty(notHandled)) {
      throw invalidMethods(extractionContext,"only paired getter/setter methods are supported",notHandled);
    }
    ModelSchema<R> schema=ModelSchema.struct(type,properties);
    Iterable<ModelSchemaExtractionContext<?>> propertyDependencies=Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toPropertyExtractionContext(extractionContext,property,cache);
      }
    }
);
    return new ModelSchemaExtractionResult<R>(schema,propertyDependencies);
  }
 else {
    return null;
  }
}
