{
  ModelType<R> type=extractionContext.getType();
  if (type.getRawClass().isAnnotationPresent(Managed.class)) {
    validateType(type,extractionContext);
    Iterable<Method> methods=removeEquivalentMethods(type.getRawClass().getMethods());
    if (Iterables.isEmpty(methods)) {
      return new ModelSchemaExtractionResult<R>(ModelSchema.struct(type,Collections.<ModelProperty<?>>emptySet()));
    }
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    Map<String,Method> methodsByName=Maps.newHashMap();
    for (    Method method : methods) {
      String name=method.getName();
      if (methodsByName.containsKey(name)) {
        throw invalidMethods(extractionContext,"overloaded methods are not supported",ImmutableList.of(method,methodsByName.get(name)));
      }
      methodsByName.put(name,method);
    }
    List<Method> handled=Lists.newArrayList();
    for (    Method method : methods) {
      String methodName=method.getName();
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        if (method.getParameterTypes().length != 0) {
          throw invalidMethod(extractionContext,"getter methods cannot take parameters",method);
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,"the 4th character of the getter method name must be an uppercase character",method);
        }
        ModelType<?> returnType=ModelType.of(method.getGenericReturnType());
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        boolean isWritable=methodsByName.containsKey(setterName);
        if (isWritable) {
          Method setter=methodsByName.get(setterName);
          validateSetter(extractionContext,returnType,setter);
          handled.add(setter);
        }
        properties.add(ModelProperty.of(returnType,propertyName,isWritable));
        handled.add(method);
      }
    }
    Iterable<Method> notHandled=Iterables.filter(methods,Predicates.not(Predicates.in(handled)));
    if (!Iterables.isEmpty(notHandled)) {
      throw invalidMethods(extractionContext,"only paired getter/setter methods are supported",notHandled);
    }
    ModelSchema<R> schema=ModelSchema.struct(type,properties);
    Iterable<ModelSchemaExtractionContext<?>> propertyDependencies=Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toPropertyExtractionContext(extractionContext,property,cache);
      }
    }
);
    return new ModelSchemaExtractionResult<R>(schema,propertyDependencies);
  }
 else {
    return null;
  }
}
