{
  ModelType<R> type=extractionContext.getType();
  if (type.getRawClass().isAnnotationPresent(Managed.class)) {
    validateType(type,extractionContext);
    List<Method> methodList=Arrays.asList(type.getRawClass().getDeclaredMethods());
    if (methodList.isEmpty()) {
      return new ModelSchemaExtractionResult<R>(ModelSchema.struct(type,Collections.<ModelProperty<?>>emptyList()));
    }
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    Map<String,Method> methods=Maps.newHashMap();
    for (    Method method : methodList) {
      String name=method.getName();
      if (methods.containsKey(name)) {
        throw invalidMethod(extractionContext,name,"overloaded methods are not supported.");
      }
      methods.put(name,method);
    }
    List<String> methodNames=Lists.newLinkedList(methods.keySet());
    List<String> handled=Lists.newArrayList();
    for (    String methodName : methodNames) {
      Method method=methods.get(methodName);
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        if (method.getParameterTypes().length != 0) {
          throw invalidMethod(extractionContext,methodName,"getter methods cannot take parameters.");
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,methodName,"the 4th character of the getter method name must be an uppercase character.");
        }
        ModelType<?> returnType=ModelType.of(method.getGenericReturnType());
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        boolean isWritable=methods.containsKey(setterName);
        if (isWritable) {
          validateSetter(extractionContext,returnType,methods.get(setterName));
          handled.add(setterName);
        }
        properties.add(ModelProperty.of(returnType,propertyName,isWritable));
        handled.add(methodName);
      }
    }
    methodNames.removeAll(handled);
    if (!methodNames.isEmpty()) {
      throw new InvalidManagedModelElementTypeException(extractionContext,"only paired getter/setter methods are supported (invalid methods: [" + Joiner.on(", ").join(methodNames) + "]).");
    }
    ModelSchema<R> schema=ModelSchema.struct(type,properties);
    return new ModelSchemaExtractionResult<R>(schema,Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toExtractionContext(extractionContext,property,cache);
      }
    }
));
  }
 else {
    return null;
  }
}
