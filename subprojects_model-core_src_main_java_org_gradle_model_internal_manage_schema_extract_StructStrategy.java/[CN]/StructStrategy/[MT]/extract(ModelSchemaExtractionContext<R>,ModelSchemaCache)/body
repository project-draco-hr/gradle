{
  ModelType<R> type=extractionContext.getType();
  Class<? super R> clazz=type.getRawClass();
  if (clazz.isAnnotationPresent(Managed.class)) {
    validateType(type,extractionContext);
    ImmutableListMultimap<String,Method> methodsByName=Multimaps.index(Arrays.asList(clazz.getMethods()),new Function<Method,String>(){
      public String apply(      Method method){
        return method.getName();
      }
    }
);
    ensureNoOverloadedMethods(extractionContext,methodsByName);
    List<ModelProperty<?>> properties=Lists.newLinkedList();
    List<Method> handled=Lists.newArrayListWithCapacity(clazz.getMethods().length);
    for (    String methodName : methodsByName.keySet()) {
      if (methodName.startsWith("get") && !methodName.equals("get")) {
        ImmutableList<Method> getterMethods=methodsByName.get(methodName);
        Method sampleMethod=getterMethods.get(0);
        if (sampleMethod.getParameterTypes().length != 0) {
          throw invalidMethod(extractionContext,"getter methods cannot take parameters",sampleMethod);
        }
        Character getterPropertyNameFirstChar=methodName.charAt(3);
        if (!Character.isUpperCase(getterPropertyNameFirstChar)) {
          throw invalidMethod(extractionContext,"the 4th character of the getter method name must be an uppercase character",sampleMethod);
        }
        ModelType<?> returnType=ModelType.of(sampleMethod.getGenericReturnType());
        String propertyNameCapitalized=methodName.substring(3);
        String propertyName=StringUtils.uncapitalize(propertyNameCapitalized);
        String setterName="set" + propertyNameCapitalized;
        ImmutableList<Method> setterMethods=methodsByName.get(setterName);
        boolean isWritable=!setterMethods.isEmpty();
        if (isWritable) {
          validateSetter(extractionContext,returnType,setterMethods.get(0));
          handled.addAll(setterMethods);
        }
        ImmutableSet<ModelType<?>> declaringClasses=ImmutableSet.copyOf(Iterables.transform(getterMethods,new Function<Method,ModelType<?>>(){
          public ModelType<?> apply(          Method input){
            return ModelType.of(input.getDeclaringClass());
          }
        }
));
        properties.add(ModelProperty.of(returnType,propertyName,isWritable,declaringClasses));
        handled.addAll(getterMethods);
      }
    }
    Iterable<Method> notHandled=Iterables.filter(methodsByName.values(),Predicates.not(Predicates.in(handled)));
    if (!Iterables.isEmpty(notHandled)) {
      throw invalidMethods(extractionContext,"only paired getter/setter methods are supported",notHandled);
    }
    ModelSchema<R> schema=ModelSchema.struct(type,properties);
    Iterable<ModelSchemaExtractionContext<?>> propertyDependencies=Iterables.transform(properties,new Function<ModelProperty<?>,ModelSchemaExtractionContext<?>>(){
      public ModelSchemaExtractionContext<?> apply(      final ModelProperty<?> property){
        return toPropertyExtractionContext(extractionContext,property,cache);
      }
    }
);
    return new ModelSchemaExtractionResult<R>(schema,propertyDependencies);
  }
 else {
    return null;
  }
}
