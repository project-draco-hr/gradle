{
  return new Action<ModelSchemaExtractionContext<P>>(){
    @Override public void execute(    ModelSchemaExtractionContext<P> propertyExtractionContext){
      ModelProperty<P> property=propertyResult.getProperty();
      if (!property.getStateManagementType().equals(ModelProperty.StateManagementType.MANAGED)) {
        return;
      }
      ModelSchemaExtractionContext<?> parentContext=propertyExtractionContext.getParent();
      if (property.getName().equals("name") && Named.class.isAssignableFrom(parentContext.getType().getRawClass())) {
        return;
      }
      ModelSchema<P> propertySchema=modelSchemaCache.get(property.getType());
      boolean isAllowedPropertyTypeOfManagedType=propertySchema instanceof ManagedImplModelSchema || propertySchema instanceof ModelValueSchema;
      boolean isDeclaredAsHavingUnmanagedType=propertyResult.getGetter().isAnnotationPresent(Unmanaged.class);
      if (isAllowedPropertyTypeOfManagedType && isDeclaredAsHavingUnmanagedType) {
        throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' is marked as @Unmanaged, but is of @Managed type '%s'. Please remove the @Managed annotation.%n",property.getName(),property.getType()));
      }
      if (!isAllowedPropertyTypeOfManagedType && !isDeclaredAsHavingUnmanagedType) {
        throw new InvalidManagedModelElementTypeException(parentContext,String.format("type %s cannot be used for property '%s' as it is an unmanaged type (please annotate the getter with @org.gradle.model.Unmanaged if you want this property to be unmanaged).%n%s",property.getType(),property.getName(),ModelSchemaExtractor.getManageablePropertyTypesDescription()));
      }
      if (!property.isWritable()) {
        if (isDeclaredAsHavingUnmanagedType) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("unmanaged property '%s' cannot be read only, unmanaged properties must have setters",property.getName()));
        }
        if (!(propertySchema instanceof ManagedImplModelSchema)) {
          throw new InvalidManagedModelElementTypeException(parentContext,String.format("read only property '%s' has non managed type %s, only managed types can be used",property.getName(),property.getType()));
        }
      }
      if (propertySchema instanceof ModelCollectionSchema) {
        ModelCollectionSchema<P,?> propertyCollectionsSchema=(ModelCollectionSchema<P,?>)propertySchema;
        ModelType<?> elementType=propertyCollectionsSchema.getElementType();
        ModelSchema<?> elementTypeSchema=modelSchemaCache.get(elementType);
        if (propertySchema instanceof ScalarCollectionSchema) {
          if (!ScalarTypes.isScalarType(elementType)) {
            throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot be a collection of type %s as it is not a scalar type.",property.getName(),elementType));
          }
        }
 else {
          if (property.isWritable()) {
            throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot have a setter (%s properties must be read only).",property.getName(),property.getType().toString()));
          }
          if (!(elementTypeSchema instanceof ManagedImplModelSchema)) {
            throw new InvalidManagedModelElementTypeException(parentContext,String.format("property '%s' cannot be a model map of type %s as it is not a %s type.",property.getName(),elementType,Managed.class.getName()));
          }
        }
      }
    }
  }
;
}
