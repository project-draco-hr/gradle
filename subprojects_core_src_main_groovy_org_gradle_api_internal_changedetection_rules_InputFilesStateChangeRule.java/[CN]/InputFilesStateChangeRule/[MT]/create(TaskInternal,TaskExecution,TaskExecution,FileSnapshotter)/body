{
  final FileCollectionSnapshot inputFilesSnapshot=inputFilesSnapshotter.snapshot(task.getInputs().getFiles());
  return new TaskStateChanges(){
    private final FileChangeCache fileChangeCache=new FileChangeCache();
    public void findChanges(    final UpToDateChangeListener listener){
      if (previousExecution.getInputFilesSnapshot() == null) {
        if (listener.isAccepting()) {
          listener.accept(new DescriptiveChange("Input file history is not available."));
        }
        return;
      }
      for (      FileChange cachedChange : fileChangeCache) {
        if (!listener.isAccepting()) {
          return;
        }
        listener.accept(cachedChange);
      }
      processUncachedChanges(listener);
    }
    private void processUncachedChanges(    final UpToDateChangeListener listener){
      inputFilesSnapshot.changesSince(previousExecution.getInputFilesSnapshot(),new FileCollectionSnapshot.SnapshotChangeListener(){
        public void added(        String fileName){
          accept(new InputFileChange(fileName,ChangeType.ADDED));
        }
        public void removed(        String fileName){
          accept(new InputFileChange(fileName,ChangeType.REMOVED));
        }
        public void changed(        String fileName){
          accept(new InputFileChange(fileName,ChangeType.MODIFIED));
        }
        public String getResumeAfter(){
          return fileChangeCache.getLastChange();
        }
        public boolean isStopped(){
          return !listener.isAccepting();
        }
        private void accept(        InputFileChange change){
          listener.accept(change);
          fileChangeCache.cache(change);
        }
      }
);
    }
    public void snapshotAfterTask(){
      currentExecution.setInputFilesSnapshot(inputFilesSnapshot);
    }
  }
;
}
