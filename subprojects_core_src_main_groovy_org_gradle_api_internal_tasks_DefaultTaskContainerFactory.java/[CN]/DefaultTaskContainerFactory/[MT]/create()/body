{
  ModelReference<DefaultTaskContainer> containerReference=ModelReference.of(TaskContainerInternal.MODEL_PATH,DefaultTaskContainer.class);
  ModelRegistrations.Builder registrationBuilder=BridgedCollections.registration(containerReference,new Transformer<DefaultTaskContainer,MutableModelNode>(){
    @Override public DefaultTaskContainer transform(    MutableModelNode mutableModelNode){
      return instantiator.newInstance(DefaultTaskContainer.class,mutableModelNode,project,instantiator,taskFactory,projectAccessListener);
    }
  }
,new Task.Namer(),"Project.<init>.tasks()",new Namer());
  modelRegistry.registerOrReplace(registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(Task.class,ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>,MutableModelNode>(){
    @Override public NamedEntityInstantiator<Task> transform(    MutableModelNode modelNode){
      return modelNode.getPrivateData(ModelType.of(DefaultTaskContainer.class)).getEntityInstantiator();
    }
  }
)))).withProjection(UnmanagedModelProjection.of(TaskContainer.class)).build());
  ModelNode modelNode=modelRegistry.atStateOrLater(TaskContainerInternal.MODEL_PATH,ModelNode.State.Created);
  if (modelNode == null) {
    throw new IllegalStateException("Couldn't get task container from model registry");
  }
  MutableModelNode mutableModelNode=(MutableModelNode)modelNode;
  mutableModelNode.applyToAllLinks(ModelActionRole.Mutate,DirectNodeNoInputsModelAction.of(ModelReference.of(Task.class),new SimpleModelRuleDescriptor("copyToTaskContainer"),new BiAction<MutableModelNode,Task>(){
    @Override public void execute(    MutableModelNode modelNode,    Task task){
      TaskContainerInternal taskContainer=modelNode.getParent().getPrivateData(TaskContainerInternal.MODEL_TYPE);
      taskContainer.add(task);
    }
  }
));
  return mutableModelNode.getPrivateData(TaskContainerInternal.MODEL_TYPE);
}
