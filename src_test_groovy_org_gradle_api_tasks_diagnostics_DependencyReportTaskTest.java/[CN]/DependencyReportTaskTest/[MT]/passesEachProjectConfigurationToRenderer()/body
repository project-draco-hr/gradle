{
  final DependencyManagerInternal dependencyManager=context.mock(DependencyManagerInternal.class);
  final ConfigurationResolver configuration1=context.mock(ConfigurationResolver.class,"Configuration1");
  final ConfigurationResolver configuration2=context.mock(ConfigurationResolver.class,"Configuration2");
  final ResolveReport report=new ResolveReport(new DefaultModuleDescriptor(new ModuleRevisionId(new ModuleId("org","mod"),"rev"),"status",null));
  final FilterSpec<ResolveInstruction> resolveInstructionMatcher=new FilterSpec<ResolveInstruction>(){
    public boolean isSatisfiedBy(    ResolveInstruction element){
      return element.isFailOnResolveError() == false;
    }
  }
;
  context.checking(new Expectations(){
{
      allowing(project).getDependencies();
      will(returnValue(dependencyManager));
      allowing(dependencyManager).getConfigurations();
      will(returnValue(WrapUtil.toList(configuration2,configuration1)));
      allowing(configuration1).getName();
      will(returnValue("config1"));
      allowing(configuration2).getName();
      will(returnValue("config2"));
      Sequence resolve=context.sequence("resolve");
      Sequence render=context.sequence("render");
      one(configuration1).resolveAsReport(with(Matchers.modifierMatcher(resolveInstructionMatcher)));
      inSequence(resolve);
      will(returnValue(report));
      one(renderer).startConfiguration(configuration1);
      inSequence(render);
      one(renderer).render(with(aNonNull(IvyDependencyGraph.class)));
      inSequence(render);
      one(renderer).completeConfiguration(configuration1);
      inSequence(render);
      one(configuration2).resolveAsReport(with(Matchers.modifierMatcher(resolveInstructionMatcher)));
      inSequence(resolve);
      will(returnValue(report));
      one(renderer).startConfiguration(configuration2);
      inSequence(render);
      one(renderer).render(with(aNonNull(IvyDependencyGraph.class)));
      inSequence(render);
      one(renderer).completeConfiguration(configuration2);
      inSequence(render);
    }
  }
);
  task.generate(project);
}
