{
  final Map<String,TaskPropertyInfo> properties=Maps.newHashMap();
  Types.walkTypeHierarchy(type,IGNORED_SUPER_CLASSES,new Types.TypeVisitor<T>(){
    @Override public void visitType(    Class<? super T> type){
      Map<String,Field> fields=getFields(type);
      for (      Method method : type.getDeclaredMethods()) {
        PropertyAccessorType accessorType=PropertyAccessorType.of(method);
        if (accessorType == null || accessorType == PropertyAccessorType.SETTER || method.isBridge() || GroovyMethods.isObjectMethod(method)) {
          continue;
        }
        String fieldName=accessorType.propertyNameFor(method);
        Field field=fields.get(fieldName);
        String propertyName=parent != null ? parent.getName() + '.' + fieldName : fieldName;
        TaskPropertyInfo propertyInfo=properties.get(propertyName);
        if (propertyInfo == null) {
          propertyInfo=new TaskPropertyInfo(TaskClassValidator.this,parent,propertyName,method,field);
          properties.put(propertyName,propertyInfo);
        }
 else {
          if (propertyInfo.getInstanceVariableField() == null && field != null) {
            propertyInfo.setInstanceVariableField(field);
          }
        }
        propertyInfo.addAnnotations(method.getDeclaredAnnotations());
        if (field != null) {
          propertyInfo.addAnnotations(field.getDeclaredAnnotations());
        }
      }
    }
  }
);
  for (  TaskPropertyInfo propertyInfo : properties.values()) {
    boolean annotationFound=attachValidationActions(propertyInfo);
    if (propertyInfo.isValidationRequired()) {
      validatedProperties.add(propertyInfo);
    }
    String propertyName=propertyInfo.getName();
    allPropertyNames.add(propertyName);
    if (annotationFound) {
      annotatedPropertyNames.add(propertyName);
    }
  }
}
