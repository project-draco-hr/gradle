{
  Types.walkTypeHierarchy(type,IGNORED_SUPER_CLASSES,new Types.TypeVisitor<T>(){
    @Override public void visitType(    Class<? super T> type){
      Map<String,Field> fields=getFields(type);
      for (      Method method : type.getDeclaredMethods()) {
        PropertyAccessorType accessorType=PropertyAccessorType.of(method);
        if (accessorType == null || accessorType == PropertyAccessorType.SETTER || method.isBridge() || GroovyMethods.isObjectMethod(method)) {
          continue;
        }
        String fieldName=accessorType.propertyNameFor(method);
        Field field=fields.get(fieldName);
        String propertyName=parent != null ? parent.getName() + '.' + fieldName : fieldName;
        TaskPropertyInfo propertyInfo=new TaskPropertyInfo(TaskClassValidator.this,parent,propertyName,method,field);
        boolean annotationFound=attachValidationActions(propertyInfo,field);
        if (propertyInfo.isValidationRequired()) {
          validatedProperties.add(propertyInfo);
        }
        allPropertyNames.add(propertyName);
        if (annotationFound) {
          annotatedPropertyNames.add(propertyName);
        }
      }
    }
  }
);
}
