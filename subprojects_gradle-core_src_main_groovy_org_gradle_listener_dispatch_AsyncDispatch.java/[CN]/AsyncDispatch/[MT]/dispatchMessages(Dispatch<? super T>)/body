{
  while (true) {
    List<T> messages=new ArrayList<T>();
    lock.lock();
    try {
      while (state == State.Dispatching && queue.isEmpty()) {
        try {
          condition.await();
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
      if (!queue.isEmpty()) {
        messages.addAll(queue);
      }
    }
  finally {
      lock.unlock();
    }
    if (messages.isEmpty()) {
      return;
    }
    for (    T message : messages) {
      dispatch.dispatch(message);
    }
    lock.lock();
    try {
      queue.subList(0,messages.size()).clear();
      condition.signalAll();
    }
  finally {
      lock.unlock();
    }
  }
}
