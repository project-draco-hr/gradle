{
  final ModelReference<T> reference=ModelReference.of(modelPath,viewType);
  modelRegistry.configure(ModelActionRole.Initialize,DirectNodeNoInputsModelAction.of(reference,descriptor,new Action<MutableModelNode>(){
    @Override public void execute(    MutableModelNode mutableModelNode){
      final TransformedClosure transformedClosure=(TransformedClosure)closure;
      InputReferences inputs=transformedClosure.getInputReferences();
      List<InputReference> inputReferences=inputs.getAllReferences();
      final Map<String,PotentialInput> inputValues=Maps.newLinkedHashMap();
      List<ModelReference<?>> inputModelReferences=Lists.newArrayList();
      for (int i=0; i < inputReferences.size(); i++) {
        InputReference inputReference=inputReferences.get(i);
        String description=String.format("@ line %d",inputReference.getLineNumber());
        String path=inputReference.getPath();
        if (!inputValues.containsKey(path)) {
          inputValues.put(path,new PotentialInput(inputModelReferences.size()));
          inputModelReferences.add(ModelReference.untyped(ModelPath.path(path),description));
        }
      }
      mutableModelNode.applyToSelf(role,InputUsingModelAction.of(reference,descriptor,inputModelReferences,new BiAction<T,List<ModelView<?>>>(){
        @Override public void execute(        final T t,        List<ModelView<?>> modelViews){
          transformedClosure.applyRuleInputs(new PotentialInputs(modelViews,inputValues));
          ClosureBackedAction.execute(t,closure.rehydrate(null,closure.getThisObject(),closure.getThisObject()));
        }
      }
));
    }
  }
));
}
