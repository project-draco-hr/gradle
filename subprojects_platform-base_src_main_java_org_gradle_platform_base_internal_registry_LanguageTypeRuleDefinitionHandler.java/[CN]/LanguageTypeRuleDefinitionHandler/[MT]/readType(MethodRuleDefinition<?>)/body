{
  assertIsVoidMethod(ruleDefinition);
  ModelType<LanguageTypeBuilder> buildInterfaceModelType=ModelType.of(LanguageTypeBuilder.class);
  if (ruleDefinition.getReferences().size() != 1) {
    throw new InvalidModelException(String.format("Method %s must have a single parameter of type '%s'.",getDescription(),buildInterfaceModelType.toString()));
  }
  ModelType<?> builder=ruleDefinition.getReferences().get(0).getType();
  if (!buildInterfaceModelType.isAssignableFrom(builder)) {
    throw new InvalidModelException(String.format("Method %s must have a single parameter of type '%s'.",getDescription(),buildInterfaceModelType.toString()));
  }
  if (builder.getTypeVariables().size() != 1) {
    throw new InvalidModelException(String.format("Parameter of type '%s' must declare a type parameter.",buildInterfaceModelType.toString()));
  }
  ModelType<?> subType=builder.getTypeVariables().get(0);
  if (subType.isWildcard()) {
    throw new InvalidModelException(String.format("%s type '%s' cannot be a wildcard type (i.e. cannot use ? super, ? extends etc.).",StringUtils.capitalize(modelName),subType.toString()));
  }
  ModelType<? extends LanguageSourceSet> asSubclass=baseInterface.asSubclass(subType);
  if (asSubclass == null) {
    throw new InvalidModelException(String.format("%s type '%s' is not a subtype of '%s'.",StringUtils.capitalize(modelName),subType.toString(),baseInterface.toString()));
  }
  return asSubclass;
}
