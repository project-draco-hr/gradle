{
  context.setImposteriser(ClassImposteriser.INSTANCE);
  scriptCompilationHandlerMock=context.mock(ScriptCompilationHandler.class);
  scriptRunnerFactoryMock=context.mock(ScriptRunnerFactory.class);
  cacheRepositoryMock=context.mock(CacheRepository.class);
  cacheMock=context.mock(PersistentCache.class);
  testClassLoader=new URLClassLoader(new URL[0]);
  testScriptFile=new File(tmpDir.getDir(),"script/mybuild.craidle");
  cacheDir=new File(tmpDir.getDir(),"cache");
  expectedScriptCacheDir=new TestFile(cacheDir,"classes").createDir();
  expectedScriptRunner=context.mock(ScriptRunner.class);
  scriptProcessor=new DefaultScriptCompilerFactory(scriptCompilationHandlerMock,scriptRunnerFactoryMock,cacheRepositoryMock);
  source=context.mock(ScriptSource.class);
  cacheBuilder=context.mock(DirectoryCacheBuilder.class);
  context.checking(new Expectations(){
{
      Resource resource=context.mock(Resource.class);
      allowing(source).getDisplayName();
      will(returnValue("[script source]"));
      allowing(source).getClassName();
      will(returnValue("class-name"));
      allowing(source).getFileName();
      will(returnValue("file-name"));
      allowing(source).getResource();
      will(returnValue(resource));
      allowing(resource).getText();
      will(returnValue(TEST_SCRIPT_TEXT));
      allowing(cacheMock).getBaseDir();
      will(returnValue(cacheDir));
    }
  }
);
  expectedSource=new CachingScriptSource(source);
  String expectedHash=HashUtil.createHash(TEST_SCRIPT_TEXT);
  expectedCacheProperties=GUtil.map("source.filename","file-name","source.hash",expectedHash);
  originalClassLoader=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(testClassLoader);
}
