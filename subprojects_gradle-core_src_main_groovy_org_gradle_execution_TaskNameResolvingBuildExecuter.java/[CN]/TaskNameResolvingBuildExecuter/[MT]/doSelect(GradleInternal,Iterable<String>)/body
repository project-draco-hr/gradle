{
  Project defaultProject=gradle.getDefaultProject();
  Map<String,Collection<Task>> allProjectsTasksByName=null;
  Map<String,Collection<Task>> matches=new LinkedHashMap<String,Collection<Task>>();
  for (  String path : paths) {
    Map<String,Collection<Task>> tasksByName;
    String baseName;
    String prefix;
    if (path.contains(Project.PATH_SEPARATOR)) {
      prefix=StringUtils.substringBeforeLast(path,Project.PATH_SEPARATOR);
      prefix=prefix.length() == 0 ? Project.PATH_SEPARATOR : prefix;
      Project project=defaultProject.findProject(prefix);
      if (project == null) {
        throw new TaskSelectionException(String.format("Project '%s' not found in %s.",prefix,defaultProject));
      }
      baseName=StringUtils.substringAfterLast(path,Project.PATH_SEPARATOR);
      Task match=project.getTasks().findByName(baseName);
      if (match != null) {
        matches.put(path,Collections.singleton(match));
        continue;
      }
      tasksByName=new HashMap<String,Collection<Task>>();
      for (      Task task : project.getTasks().getAll()) {
        tasksByName.put(task.getName(),Collections.singleton(task));
      }
      prefix=prefix + Project.PATH_SEPARATOR;
    }
 else {
      Set<Task> tasks=defaultProject.getTasksByName(path,true);
      if (!tasks.isEmpty()) {
        matches.put(path,tasks);
        continue;
      }
      if (allProjectsTasksByName == null) {
        allProjectsTasksByName=buildTaskMap(defaultProject);
      }
      tasksByName=allProjectsTasksByName;
      baseName=path;
      prefix="";
    }
    Pattern pattern=getPatternForName(baseName);
    Set<String> patternCandidates=new TreeSet<String>();
    Set<String> typoCandidates=new TreeSet<String>();
    for (    String candidate : tasksByName.keySet()) {
      if (pattern.matcher(candidate).matches()) {
        patternCandidates.add(candidate);
      }
      if (StringUtils.getLevenshteinDistance(baseName.toUpperCase(),candidate.toUpperCase()) <= Math.min(3,baseName.length() / 2)) {
        typoCandidates.add(candidate);
      }
    }
    if (patternCandidates.size() == 1) {
      String actualName=patternCandidates.iterator().next();
      matches.put(prefix + actualName,tasksByName.get(actualName));
      continue;
    }
    if (!patternCandidates.isEmpty()) {
      throw new TaskSelectionException(String.format("Task '%s' is ambiguous in %s. Candidates are: %s.",baseName,defaultProject,GUtil.toString(patternCandidates)));
    }
    if (!typoCandidates.isEmpty()) {
      throw new TaskSelectionException(String.format("Task '%s' not found in %s. Some candidates are: %s.",baseName,defaultProject,GUtil.toString(typoCandidates)));
    }
    throw new TaskSelectionException(String.format("Task '%s' not found in %s.",baseName,defaultProject));
  }
  return matches;
}
