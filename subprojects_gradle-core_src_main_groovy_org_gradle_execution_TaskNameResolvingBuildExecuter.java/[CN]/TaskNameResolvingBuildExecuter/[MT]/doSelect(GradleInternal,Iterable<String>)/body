{
  Project project=gradle.getDefaultProject();
  Map<String,Collection<Task>> allProjectsTasksByName=null;
  Map<String,Collection<Task>> matches=new LinkedHashMap<String,Collection<Task>>();
  for (  String path : paths) {
    Map<String,Collection<Task>> tasksByName;
    String baseName;
    String prefix;
    if (path.contains(Project.PATH_SEPARATOR)) {
      String projectPath=StringUtils.substringBeforeLast(path,Project.PATH_SEPARATOR);
      projectPath=projectPath.length() == 0 ? Project.PATH_SEPARATOR : projectPath;
      project=findProject(project,projectPath);
      baseName=StringUtils.substringAfterLast(path,Project.PATH_SEPARATOR);
      Task match=project.getTasks().findByName(baseName);
      if (match != null) {
        matches.put(path,Collections.singleton(match));
        continue;
      }
      tasksByName=new HashMap<String,Collection<Task>>();
      for (      Task task : project.getTasks().getAll()) {
        tasksByName.put(task.getName(),Collections.singleton(task));
      }
      prefix=project.getPath() + Project.PATH_SEPARATOR;
    }
 else {
      Set<Task> tasks=project.getTasksByName(path,true);
      if (!tasks.isEmpty()) {
        matches.put(path,tasks);
        continue;
      }
      if (allProjectsTasksByName == null) {
        allProjectsTasksByName=buildTaskMap(project);
      }
      tasksByName=allProjectsTasksByName;
      baseName=path;
      prefix="";
    }
    NameMatcher matcher=new NameMatcher();
    String actualName=matcher.find(baseName,tasksByName.keySet());
    if (actualName != null) {
      matches.put(prefix + actualName,tasksByName.get(actualName));
      continue;
    }
    throw new TaskSelectionException(matcher.formatErrorMessage("task",project));
  }
  return matches;
}
