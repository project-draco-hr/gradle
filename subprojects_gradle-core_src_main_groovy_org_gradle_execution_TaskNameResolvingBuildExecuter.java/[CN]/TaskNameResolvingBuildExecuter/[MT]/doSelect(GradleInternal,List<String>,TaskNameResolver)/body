{
  SetMultimap<String,Task> matches=LinkedHashMultimap.create();
  TaskSelector selector=new TaskSelector(taskNameResolver);
  List<String> remainingPaths=paths;
  while (!remainingPaths.isEmpty()) {
    String path=remainingPaths.get(0);
    selector.selectTasks(gradle,path);
    CommandLineParser commandLineParser=new CommandLineParser();
    Set<Task> tasks=selector.getTasks();
    Map<String,JavaMethod<Task,?>> options=new HashMap<String,JavaMethod<Task,?>>();
    if (tasks.size() == 1) {
      for (Class<?> type=tasks.iterator().next().getClass(); type != Object.class; type=type.getSuperclass()) {
        for (        Method method : type.getDeclaredMethods()) {
          CommandLineOption commandLineOption=method.getAnnotation(CommandLineOption.class);
          if (commandLineOption != null) {
            commandLineParser.option(commandLineOption.options()).hasDescription(commandLineOption.description());
            options.put(commandLineOption.options()[0],new JavaMethod<Task,Object>(Task.class,Object.class,method));
          }
        }
      }
    }
    ParsedCommandLine commandLine=commandLineParser.parse(remainingPaths.subList(1,remainingPaths.size()));
    for (    Map.Entry<String,JavaMethod<Task,?>> entry : options.entrySet()) {
      if (commandLine.hasOption(entry.getKey())) {
        for (        Task task : tasks) {
          entry.getValue().invoke(task,true);
        }
      }
    }
    remainingPaths=commandLine.getExtraArguments();
    matches.putAll(selector.getTaskName(),tasks);
  }
  return matches;
}
