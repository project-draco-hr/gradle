{
  final ModelType<T> type=ModelType.of(source);
  DefaultMethodModelRuleExtractionContext context=new DefaultMethodModelRuleExtractionContext(type,this);
  StructSchema<T> schema=getSchema(source,context);
  if (schema == null) {
    throw new InvalidModelRuleDeclarationException(context.problems.format());
  }
  Set<Method> methods=new TreeSet<Method>(Ordering.usingToString());
  methods.addAll(Arrays.asList(source.getDeclaredMethods()));
  for (  ModelProperty<?> property : schema.getProperties()) {
    for (    WeaklyTypeReferencingMethod<?,?> method : property.getGetters()) {
      methods.remove(method.getMethod());
    }
    if (property.getSetter() != null) {
      methods.remove(property.getSetter().getMethod());
    }
  }
  ImmutableList.Builder<ExtractedModelRule> registrations=ImmutableList.builder();
  for (  Method method : methods) {
    MethodRuleDefinition<?,?> ruleDefinition=DefaultMethodRuleDefinition.create(source,method);
    ExtractedModelRule registration=getMethodHandler(ruleDefinition,method,context);
    if (registration != null) {
      registrations.add(registration);
    }
  }
  if (context.hasProblems()) {
    throw new InvalidModelRuleDeclarationException(context.problems.format());
  }
  if (schema.getProperties().isEmpty()) {
    return new StatelessRuleSource(registrations.build(),Modifier.isAbstract(source.getModifiers()) ? new AbstractRuleSourceFactory<T>(schema,proxyFactory) : new ConcreteRuleSourceFactory<T>(type));
  }
 else {
    return new ParameterizedRuleSource(registrations.build(),schema,proxyFactory);
  }
}
