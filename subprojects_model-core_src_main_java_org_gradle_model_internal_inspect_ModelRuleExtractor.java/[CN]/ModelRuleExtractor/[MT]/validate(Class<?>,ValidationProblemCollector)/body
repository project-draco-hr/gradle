{
  int modifiers=source.getModifiers();
  if (Modifier.isInterface(modifiers)) {
    problems.add("must be a class, not an interface");
  }
  if (!RuleSource.class.isAssignableFrom(source) || !source.getSuperclass().equals(RuleSource.class)) {
    problems.add("rule source classes must directly extend " + RuleSource.class.getName());
  }
  if (Modifier.isAbstract(modifiers)) {
    problems.add("class cannot be abstract");
  }
  if (source.getEnclosingClass() != null) {
    if (Modifier.isStatic(modifiers)) {
      if (Modifier.isPrivate(modifiers)) {
        problems.add("class cannot be private");
      }
    }
 else {
      problems.add("enclosed classes must be static and non private");
    }
  }
  Constructor<?>[] constructors=source.getDeclaredConstructors();
  for (  Constructor<?> constructor : constructors) {
    if (constructor.getParameterTypes().length > 0) {
      problems.add("cannot declare a constructor that takes arguments");
      break;
    }
  }
  Field[] fields=source.getDeclaredFields();
  for (  Field field : fields) {
    int fieldModifiers=field.getModifiers();
    if (!field.isSynthetic() && !(Modifier.isStatic(fieldModifiers) && Modifier.isFinal(fieldModifiers))) {
      problems.add("field " + field.getName() + " is not static final");
    }
  }
}
